<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, viewport-fit=cover">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Project Map</title>

  <!-- Font Awesome CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

  <!-- Leaflet CSS / JS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- XLSX for reading .xls / .xlsx / .xlsm -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <style>
    /* 基本リセット */
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    /* 全体レイアウト */
    body {
      font-family: Arial, sans-serif;
      height: calc(var(--vh, 1vh) * 100);
      overflow: hidden; 
      display: flex;
      flex-direction: column;
    }

    /* 共通メニュースタイル */
    .menu {
      position: fixed;
      background: rgba(255, 255, 255, 0.95);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      transition: transform 0.3s ease-in-out;
      z-index: 3002;
    }

    /* メディアクエリ: モバイル */
    @media screen and (max-width: 768px) {
      /* メニューコンテナのスタイル */
      #menuContainer {
        position: fixed;
        bottom: -66%;
        left: 0;
        width: 100%;
        height: 70%;
        border-radius: 15px 15px 0 0;
        background: rgba(255, 255, 255, 0.95);
        transition: transform 0.3s ease-out, bottom 0.3s ease-out;
        z-index: 1000;
      }

      /* メニューの状態 */
      #menuContainer.closed { bottom: -66%; }
      #menuContainer.half { bottom: -30%; }
      #menuContainer.full { bottom: 0; }

      /* ドラッグハンドル */
      .menu-header {
        width: 100%;
        height: 30px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 15px 15px 0 0;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: grab;
      }

      .drag-handle {
        width: 50px;
        height: 5px;
        background: #999;
        border-radius: 2.5px;
      }

      /* メニュートグルボタンを非表示に */
      .menu-toggle { display: none !important; }
      
      .zoom-container {
        bottom: 50px;
      }
      
      /* Transition for moving the container */
      .zoom-container.moved-left {
        right: auto;
        left: 11px;
      }      
      
    }

    /* メディアクエリ: デスクトップ/タブレット */
    @media screen and (min-width: 769px) {
      #menuContainer {
        top: 0;
        left: 0;
        width: 320px;
        height: 100%;
        border-radius: 0 15px 15px 0;
        transform: translateX(-320px);
        transition: transform 0.3s ease-out;
      }

      #menuContainer.open { transform: translateX(0); }

      /* メニュートグルボタンのスタイル */
      .menu-toggle {
        position: fixed;
        top: 34px;
        left: 15px;
        transform: translateY(-50%);
        background: none;
        font-size: 30px;
        color: #555;
        border: none;
        /* border-radius: 0 5px 5px 0; */
        padding: 8px 12px;
        cursor: pointer;
        /* box-shadow: 2px 0 5px rgba(0,0,0,0.1); */
        z-index: 1001;
        transition: color 0.3s;
      }

      .menu-toggle:hover { color: #333; }

      /* メニューコンテンツ */
      .menu-content {
        width: 100%;
        height: 100%;
        background: white;
        overflow-y: auto;
        padding: 10px;
      }

      /* PCではメニューヘッダーを非表示 */
      .menu-header { display: none !important; }
      
      .zoom-container {
        bottom: 20px;
      }
      
      /* Transition for moving the container */
      .zoom-container.moved-left {
        right: auto;
        left: 16px;
      }  
      
    }

    /* その他のスタイル */
    #top-bar {
      background: #f8f9fa;
      margin-left: 5px;
      padding: 5px 15px;
      display: flex;
      gap: 10px;
      align-items: center;
    }

    /* top-bar の入力欄（info-iconなし） */
    #top-bar .search-container input {
        padding: 0px 35px 0px 10px; /* 右側のみclear-iconのスペース */
        border: 1px solid grey;
        border-radius: 15px;
        font-size: 16px;
    }

    /* 検索コンテナ */
    .search-container {
      position: relative;
      display: inline-block;
    }

    /* propertyContainer の入力欄（info-iconあり） */
    #propertyContainer .search-container input {
        padding: 0px 35px 0px 35px; /* 両側にアイコンのスペース */
        border: 1px solid grey;
        border-radius: 15px;
        font-size: 16px;
        z-index: 3001;
    }

    .info-icon {
      position: absolute;
      left: 8px;
      top: 18%;
      transform: translateY(-0%);
      width: 20px;
      height: 20px;
      cursor: pointer;
      opacity: 0.7;
      transition: opacity 0.3s, transform 0.3s;
    }

    .info-icon:hover {
      opacity: 1;
      transform: scale(1.2);
    }

    .clear-icon {
      position: absolute;
      right: 8px;
      top: 14%;
      transform: translateY(-0%);
      width: 23px;
      height: 23px;
      cursor: pointer;
      display: none;
      opacity: 0.7;
      transition: opacity 0.3s, transform 0.3s;
    }

    .clear-icon:hover {
      opacity: 1;
      transform: scale(1.2);
    }

    .search-container:has(input:not(:placeholder-shown)) .clear-icon {
      display: block;
    }

    /* カスタムファイル入力 */
    .custom-file-input {
        color: #333;
        font-size: 20px;
        margin-right: 0px;
        display: inline-block;
        padding: 4px 12px;
        cursor: pointer;
        border-radius: 8px;
        transition: background-color 0.3s;
    }

    .custom-file-input:hover {
        background-color: #ddd;
    }

    #fileInput { display: none; }

    /* 地図スタイル */
    #map {
      flex: 1;
      position: relative;
      height: calc(var(--vh, 1vh) * 100);
      width: 100%;
      z-index: 0;
    }

    /* ボタンスタイル */
    #currentLocationBtn, #layerToggleBtn {
      position: fixed;
      z-index: 1000;
      cursor: pointer;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.3s ease;
      background: none;
      border: none;
    }

    #currentLocationBtn {
        top: 70px;
        right: 20px;
    }

    #layerToggleBtn {
        top: 21px;
        right: 20px;
    }

    #currentLocationBtn:hover, #layerToggleBtn:hover {
        transform: scale(1.2);
    }

    #currentLocationBtn img, #layerToggleBtn img {
        width: 30px;
        height: 30px;
    }
    

    /* Zoom Controls Container */
    .zoom-container {
      position: fixed;
      /* bottom: 20px; @media 設定*/
      right: 11px; /* Initial position: bottom right */
      display: flex;
      flex-direction: column;
      gap: 0px;
      z-index: 1000;
      /* background: rgba(255, 255, 255, 0.8); */
      /* border-radius: 15px; */
      padding: 5px;
      /* box-shadow: 0 2px 6px rgba(0,0,0,0.3); */
    }

    /* Zoom Buttons */
    .zoom-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 8px;
      border-radius: 4px;
      transition: transform 0.3s ease;
      font-size: 23px;
      color: rgba(0, 25, 60, 0.6);
    }

    .zoom-btn:hover {
      transform: scale(1.2);
    }

    /* Adjust icon size if necessary */
    .zoom-btn i {
      pointer-events: none; /* Prevent click events on the icon itself */
    }

    /* Transition for moving the container */
    /* @media 設定
    .zoom-container.moved-left {
      right: auto;
      left: 52px;
    }
    */
    
    

    /* 物件コンテナ */
    #propertyContainer {
      position: fixed;
      top: 15px; 
      width: 320px;
      max-height: 70vh; 
      background-color: transparent;
      z-index: 3001;
      border: 0px solid #ccc;
      border-radius: 15px;
      display: flex;
      flex-direction: column;
      pointer-events: auto;
      touch-action: pan-y; 
      overscroll-behavior: contain;
    }

    /* モバイル用 */
    #propertyContainer { left: 15px; }

    /* デスクトップ用 */
    @media screen and (min-width: 769px) {
      #propertyContainer { left: 60px; }
    }

    #propertySearchHeader {
      background: transparent;
      padding: 5px;
      display: flex;
      gap: 5px;
      flex-wrap: wrap;
      align-items: center;
    }

    #propertySearchHeader input {
      flex: 1;
      min-width: 0;
      padding: 6px 10px;
      border: 1px solid grey;
      border-radius: 15px;
      font-size: 16px;
    }

    #propertySearchHeader button {
      padding: 5px 10px;
      cursor: pointer;
      background: none;
      border: none;
      color: #555;
      transition: color 0.3s;
      font-size: 18px;
    }

    #propertySearchHeader button:hover {
      color: #333;
    }

    /* 更新されたローディングスピナー */
    .loading-spinner {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 40px;
      height: 40px;
      border: 4px solid rgba(0, 0, 0, 0.1);
      border-top: 4px solid #3498db;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      z-index: 1001;
      display: none; /* 初期状態では非表示 */
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }

    /* アニメーションの定義 */
    @keyframes spin {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }

    /* モーダルウィンドウのスタイル */
    .modal {
      display: none;
      position: fixed; 
      z-index: 3000; /* 既存のz-indexより上 */
      left: 0;
      top: 0;
      width: 100%; 
      height: 100%;
      overflow: auto; 
      background-color: rgba(0,0,0,0.4); /* 半透明の背景 */
    }

    .modal-content {
      background-color: #fefefe;
      font-size: 12px;
      margin: 70px auto; /* 上下中央に配置 */
      padding: 20px;
      border: 1px solid #888;
      width: 90%; /* 幅を調整 */
      max-width: 800px; /* 最大幅を設定 */
      border-radius: 10px;
      position: relative;
    }

    .close-button {
      color: #aaa;
      position: absolute;
      top: 10px;
      right: 20px;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }

    .close-button:hover,
    .close-button:focus {
      color: black;
      text-decoration: none;
    }

    .tabs {
      display: flex;
      border-bottom: 1px solid #ccc;
      margin-bottom: 10px;
    }

    .tab-button {
      background-color: inherit;
      border: none;
      outline: none;
      cursor: pointer;
      padding: 14px 16px;
      transition: background-color 0.3s;
      font-size: 17px;
    }

    .tab-button:hover {
      background-color: #ddd;
    }

    .tab-button.active {
      background-color: #ccc;
    }

    .tab-content {
      max-height: 60vh;
      overflow-y: auto;
    }

    .tab-panel {
      display: none;
    }

    .tab-panel.active {
      display: block;
    }




    #propertyListArea {
      flex: 1;
      overflow-y: auto;
      padding: 5px 10px;
      border: none;
      border-radius: 15px;
      background: rgba(255, 255, 255, 0.3);
      backdrop-filter: blur(5px);
      transition: all 0.3s ease;
    }

    #propertyListArea.hidden { display: none; }

    ul { list-style: none; margin: 0; padding: 0; }

    li { border-bottom: 1px solid #ccc; padding: 3px 0; }

    li:last-child { border-bottom: none; }

    .property-name {
      color: #007bff;
      text-decoration: underline;
      cursor: pointer;
    }

    .property-name:hover { color: #0056b3; }

    /* ブリンキングマーカー */
    @keyframes blink {
      0%   { opacity:1; }
      50%  { opacity:0; }
      100% { opacity:1; }
    }

    .blinking-marker {
      width: 14px;
      height: 14px;
      background-color: magenta;
      border: 2px solid white;
      border-radius: 50%;
      animation: blink 1s infinite;
    }

    /* ローディングスピナーの表示 */
    .loading {
      display: block;
    }
  </style>
</head>

<body>
  <!-- 地図コンテナ -->
  <div id="map" tabindex="0" aria-label="Map Area"></div>

  <!-- レイヤートグルボタン -->
  <button id="layerToggleBtn" role="button" aria-label="Toggle Map Layer" title="Toggle Map Layer">
      <img src="https://img.icons8.com/?size=100&id=2m4kkop8aUO5&format=png&color=000000" alt="Toggle Layer Icon" />
  </button>        
  
  <!-- 現在位置ボタン -->
  <button id="currentLocationBtn" onclick="toggleCurrentLocation()" aria-label="Toggle Current Location" title="Toggle Current Location">
      <img src="https://img.icons8.com/?size=100&id=ziC1TV1ikKi9&format=png&color=004ACD4D" alt="Show Location" />
  </button>

  <!-- Zoom Controls -->
  <div id="zoomContainer" class="zoom-container" aria-label="Zoom Controls">
    <button id="moveZoomBtn" class="zoom-btn" aria-label="Move Zoom Controls" title="Move Zoom Controls">
      <i class="fa-solid fa-caret-left"></i>
    </button>
    <button id="zoomInBtn" class="zoom-btn" aria-label="Zoom In" title="Zoom In">
      <i class="fa-solid fa-circle-plus"></i>
    </button>
    <button id="zoomOutBtn" class="zoom-btn" aria-label="Zoom Out" title="Zoom Out">
      <i class="fa-solid fa-circle-minus"></i>
    </button>
  </div>   
  
  <!-- メニュートグルボタン -->
  <button id="menuToggleBtn" class="menu-toggle" aria-label="Toggle Menu" title="Toggle Menu">
    ☰
  </button>        
  
  <!-- 物件コンテナ（検索ボックスとリスト） -->
  <div id="propertyContainer">
    <div id="propertySearchHeader">
      <!-- 物件検索ボックス -->
      <div class="search-container">
        <input
          type="text"
          id="propertySearchBox"
          placeholder="Property search"
          aria-label="Property Search Box"
        />
        <img
          src="https://img.icons8.com/?size=100&id=80585&format=png&color=000000"
          alt="Info"
          class="info-icon"
          onclick="openInfoModal()"
          aria-label="Show Search Infomation"
        />          
        <img
          src="https://img.icons8.com/?size=100&id=121477&format=png&color=75750399"
          alt="Clear"
          class="clear-icon"
          onclick="clearPropertySearch()"
          aria-label="Clear Property Search"
        />
      </div>
      <!-- リスト表示トグルボタン -->
      <button onclick="toggleList()" aria-label="Toggle Property List" title="Toggle Property List">
        <i id="toggleIcon" class="fa-solid fa-angles-down" style="color: #555"></i>
      </button>        
    </div>

    <!-- ローディングスピナー -->
    <div class="loading-spinner" id="propertyLoadingSpinner" aria-hidden="true"></div>

    <div id="propertyListArea" class="hidden">
      <ul id="propertyResultUl"></ul>
    </div>
  </div>  

  <!-- ローディングスピナー（地理検索用） -->
  <div class="loading-spinner" id="geoLoadingSpinner" aria-hidden="true"></div>


  <!-- モーダルウィンドウ -->
  <div id="infoContainer" class="modal" aria-hidden="true">
    <div class="modal-content">
      <span class="close-button" onclick="closeInfoModal()" aria-label="Close Modal">&times;</span>
      <div class="tabs">
        <button class="tab-button active" onclick="openTab('searchInfo')">Search Infomation</button>
        <button class="tab-button" onclick="openTab('sub')">Sub</button>
      </div>
      <div class="tab-content">
        <div id="searchInfo" class="tab-panel active">
          <!-- searchInfo情報がここに表示されます -->
          <p>
            1. Simple Search<br>

Purpose: Quickly find properties by name, address, or general keywords.<br>

How to Use:<br>
1.	Locate the Search Box:<br>
　•	On the Property Container panel, find the search box labeled “Property search.”<br>
2.	Enter Your Query:<br>
　•	Click on the search box and type in the name of the property, its address, or any related keyword.<br>
　•	Example Inputs:<br>
　•	Sunset Villas<br>
　•	123 Maple Street<br>
　•	Eco-friendly Apartments<br>
3.	Execute the Search:<br>
　•	Press the Enter key on your keyboard.<br>
　•	The map will display markers and polygons representing the matching properties.<br>
　•	A list of results will appear below the search box for easy reference.<br>
4.	View Property Details:<br>
　•	Click on a property name in the results list to zoom into its location on the map.<br>
　•	Alternatively, click directly on a map marker or polygon to view detailed information about the property.<br>
5.	Clear the Search:<br>
　•	Click the clear icon (✖) inside the search box to remove your query and reset the search results.<br>
<br>
Tips:<br>
•	Use specific names or addresses for the best results.<br>
•	The search is case-insensitive, so sunset villas and Sunset Villas yield the same results.<br>
          </p>
        </div>
        <div id="sub" class="tab-panel">
          <!-- sub情報がここに表示されます -->
          <p>sub</p>
        </div>
      </div>
    </div>
  </div>  

  <!-- メニューコンテナ -->
  <div id="menuContainer" class="menu" role="navigation" aria-label="Main Menu">
    <div class="menu-header" id="menuDragHandle">
      <div class="drag-handle" aria-hidden="true"></div>
    </div>
    <div class="menu-content">
      <div id="top-bar">
        <!-- 地域検索ボックス -->
        <div class="search-container">
          <input
            type="text"
            id="geoSearchBox"
            placeholder="Enter a place"
            aria-label="Geographical Search Box"
          />
          <img
            src="https://img.icons8.com/?size=100&id=121477&format=png&color=75750399"
            alt="Clear"
            class="clear-icon"
            onclick="clearGeoSearch()"
            aria-label="Clear Geographical Search"
          />
        </div>
        <!-- ファイル入力 -->
        <label for="fileInput" class="custom-file-input" tabindex="0" aria-label="Upload Excel File">
          <i class="fa-solid fa-file-arrow-down"></i>
        </label>
        <input type="file" id="fileInput" accept=".xls,.xlsx,.xlsm" aria-hidden="true" />
      </div>      
      <ul>
        <li><a href="#option1" tabindex="0">Option 1</a></li>
        <li><a href="#option2" tabindex="0">Option 2</a></li>
        <li><a href="#option3" tabindex="0">Option 3</a></li>
      </ul>
    </div>
  </div>

  <script type="module">
    // JavaScriptモジュールの開始
    (() => {
      // -------------------------------------------------------
      // 1) Initialize Leaflet map
      // -------------------------------------------------------
      const map = L.map('map', {
          zoomControl: false, // ズームボタンを非表示にする
          minZoom: 2, // 最小ズームレベルを制限
          maxZoom: 18, // 最大ズームレベルを制限  
          worldCopyJump: true
      }).setView([1, 125], 3);　   // Center of Asia Oceania     
   // }).setView([16, 105], 5);　  // Center of Vietnam
   // }).setView([54, 15], 4);　   // Center of Europe
   // }).setView([54, -105], 3);　 // Center of North America 
   // }).setView([11, -89], 5);　  // Center of Central South America     
   // }).setView([32, 35], 5);　   // Center of Midde East     
   // }).setView([3, 16], 3);　    // Center of Africa

      // 地図の最大表示範囲を設定（余白ができないようにする）
      const bounds = L.latLngBounds(
          L.latLng(-85, -Infinity), // 南西端
          L.latLng(85, Infinity)    // 北東端
      );
      map.on('drag', function () {
          map.panInsideBounds(bounds, { animate: false });
      });      

      

      // ダブルクリックズームを無効化
      map.doubleClickZoom.disable();

      // ダブルクリック時にパン
      map.on('dblclick', (e) => {
        map.panTo(e.latlng, { animate: true });
      });

      // タイルレイヤーの追加
      const streetLayer = L.tileLayer('https://api.maptiler.com/maps/basic/{z}/{x}/{y}.png?key=Sv80uSRLZxFEwRiW17Cg', {
        maxZoom: 19,
        attribution: '&copy; MapTiler &copy; OpenStreetMap contributors',
        detectRetina: true
      });

      const satelliteLayer = L.tileLayer('https://api.maptiler.com/maps/satellite/{z}/{x}/{y}.jpg?key=Sv80uSRLZxFEwRiW17Cg', {
        maxZoom: 18,
        attribution: '&copy; MapTiler & OpenStreetMap contributors'
      });

      // 初期レイヤーを地図に追加
      streetLayer.addTo(map);

      let isSatellite = false; // 現在のレイヤーフラグ

      // レイヤートグルボタンのクリックイベント
      const toggleBtn = document.getElementById('layerToggleBtn');
      toggleBtn.addEventListener('click', () => {
        toggleMapLayer();
      });

      // レイヤートグルボタンのキーボードイベント
      toggleBtn.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          toggleMapLayer();
        }
      });

      /**
       * マップレイヤーの切り替え関数
       */
      function toggleMapLayer() {
        if (isSatellite) {
            map.removeLayer(satelliteLayer);
            map.addLayer(streetLayer);
            toggleBtn.querySelector('img').src = "https://img.icons8.com/?size=100&id=2m4kkop8aUO5&format=png&color=000000"; // ストリートアイコン
            toggleBtn.querySelector('img').alt = "Switch to Satellite View";
        } else {
            map.removeLayer(streetLayer);
            map.addLayer(satelliteLayer);
            toggleBtn.querySelector('img').src = "https://img.icons8.com/?size=100&id=NHtRhybXwxli&format=png&color=000000"; // 衛星アイコン
            toggleBtn.querySelector('img').alt = "Switch to Street View";
        }
        isSatellite = !isSatellite; // 状態を切り替える
      }

      // 地図の操作を有効化
      map.dragging.enable();
      map.scrollWheelZoom.enable();

      // プロパティコンテナへのポインタ/タッチイベントで地図操作を無効化
      const propertyPanel = document.getElementById('propertyContainer');
      propertyPanel.addEventListener('pointerenter', () => {
        map.dragging.disable();
        map.scrollWheelZoom.disable();
      });
      propertyPanel.addEventListener('pointerleave', () => {
        map.dragging.enable();
        map.scrollWheelZoom.enable();
      });
      propertyPanel.addEventListener('touchstart', () => {
        map.dragging.disable();
        map.scrollWheelZoom.disable();
      });
      propertyPanel.addEventListener('touchend', () => {
        map.dragging.enable();
        map.scrollWheelZoom.enable();
      });

      // -------------------------------------------------------
      // 2) Excel reading (all columns)
      // -------------------------------------------------------
      let propertyData = [];
      const fileInput = document.getElementById('fileInput');

      fileInput.addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (!file) return;
        
        closeUIElements();

        try {
          // ローディングスピナーを表示
          showLoadingSpinner('propertyLoadingSpinner');

          const data = await readExcelFile(file);
          propertyData = parseExcelData(data);

          console.log("Excel loaded:", propertyData.length, "rows");
          alert("Excel loaded: " + propertyData.length + " properties found.");
        } catch (error) {
          console.error("Error loading Excel file:", error);
          alert("Failed to load Excel file. Please ensure the file is valid.");
        } finally {
          // ローディングスピナーを非表示
          hideLoadingSpinner('propertyLoadingSpinner');
        }
      });

      /**
       * Excelファイルを読み込む非同期関数
       * @param {File} file - ユーザーがアップロードしたファイル
       * @returns {Promise} - Excelデータの配列
       */
      async function readExcelFile(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const data = new Uint8Array(e.target.result);
              const workbook = XLSX.read(data, { type: 'array' });
              const sheetName = workbook.SheetNames[0];
              const jsonData = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName]);
              resolve(jsonData);
            } catch (error) {
              reject(error);
            }
          };
          reader.onerror = () => {
            reject(new Error("Failed to read the file."));
          };
          reader.readAsArrayBuffer(file);
        });
      }

      /**
       * Excelデータをパースして物件データ配列を作成する関数
       * @param {Array} data - Excelから読み込まれたデータ
       * @returns {Array} - パースされた物件データ
       */
      function parseExcelData(data) {
        return data.map(row => ({
          pjName:       row["PJ name"]        || "",
          address:      row["Address"]        || "",
          category1:    row["Category 1"]     || "",
          category2:    row["Category 2"]     || "",
          developer:    row["Developer"]      || "",
          architect:    row["Architect"]      || "",
          contractor:   row["Contractor"]     || "",
          salesCompany: row["Sales Company"]  || "",
          status:       row["Status"]         || "",
          siteArea:     row["Site Area"]      || "",
          latitude:     parseFloat(row["Latitude"]   || "NaN"),
          longitude:    parseFloat(row["Longitude"]  || "NaN"),
        }));
      }

      // -------------------------------------------------------
      // 3) Arrays for markers & polygons
      // -------------------------------------------------------
      const propertyMarkers = [];
      const propertyPolygons = [];

      // -------------------------------------------------------
      // 4) handlePropertySearch
      // -------------------------------------------------------
      const propertySearchBox = document.getElementById('propertySearchBox');

      propertySearchBox.addEventListener('keydown', async (event) => {
          if (event.key === 'Enter') {
              await handlePropertySearch();
          }
      });

      /**
       * 物件検索処理
       */
      async function handlePropertySearch() {
        const query = propertySearchBox.value.trim();
        if (!query) {
          alert("Please enter a property search query.");
          return;
        }

        closeUIElements();

        try {
          // ローディングスピナーを表示
          showLoadingSpinner('propertyLoadingSpinner');

          // 既存のマーカーとポリゴンを削除
          propertyMarkers.forEach(m => map.removeLayer(m));
          propertyMarkers.length = 0;
          propertyPolygons.forEach(p => map.removeLayer(p));
          propertyPolygons.length = 0;

          const ul = document.getElementById('propertyResultUl');
          ul.innerHTML = "";

          let results = [];
          const complexPattern = /[:=()><]|(AND\b)|(OR\b)|(NOT\b)/i;
          if (complexPattern.test(query)) {
            results = parseComplexQuery(query, propertyData);
          } else {
            results = simpleSearch(propertyData, query);
          }
          if (results.length === 0) {
            alert("No matching properties found.");
            return;
          }

          const searchBounds = L.latLngBounds();

          results.forEach((item) => {
            const li = document.createElement('li');
            const nameSpan = document.createElement('span');
            nameSpan.className = "property-name";
            nameSpan.textContent = item.pjName || "(No Name)";
            nameSpan.onclick = () => zoomToItem(item);
            nameSpan.setAttribute('tabindex', '0');
            nameSpan.setAttribute('role', 'button');
            nameSpan.setAttribute('aria-pressed', 'false');
            nameSpan.addEventListener('keydown', (e) => {
              if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                zoomToItem(item);
              }
            });
            li.appendChild(nameSpan);
            ul.appendChild(li);

            if (!isNaN(item.latitude) && !isNaN(item.longitude)) {
              const marker = createMarkerWithCategoryStyle(item);
              propertyMarkers.push(marker);
              searchBounds.extend(marker.getLatLng());
            }
            if (item.siteArea) {
              try {
                const coords = JSON.parse(item.siteArea);
                if (Array.isArray(coords) && coords.length >= 3) {
                  const polygon = createPolygonWithCategoryStyle(item, coords);
                  propertyPolygons.push(polygon);
                  searchBounds.extend(polygon.getBounds());
                }
              } catch(e) {
                console.warn("Invalid siteArea for", item.pjName, e);
              }
            }
          });

          if (searchBounds.isValid()) {
            map.fitBounds(searchBounds, { padding: [20, 20] });
          }
        } catch (error) {
          console.error("Error during property search:", error);
          alert("An error occurred during the search. Please try again.");
        } finally {
          // ローディングスピナーを非表示
          hideLoadingSpinner('propertyLoadingSpinner');
        }
      }

      /**
       * マーカー作成関数
       * @param {Object} item - 物件データ
       * @returns {Object} - Leafletマーカー
       */
      function createMarkerWithCategoryStyle(item) {
          const latLng = [item.latitude, item.longitude];
          let customIcon = getCategoryIcon(item.category1);

          const marker = L.marker(latLng, { icon: customIcon }).addTo(map);
          marker.bindPopup(buildPopup(item));
          return marker;
      }

      // カテゴリーごとのアイコンサイズを定義するマッピング
      const categoryIconSizes = {
          'primary': [15, 15],
          'area': [0, 0],
          'haseko': [20, 20],
          'ecoba': [20, 20],
          'condominium': [15, 15],
          'others': [20, 20],
          'pj site': [0, 0],
          'default': [20, 20] // デフォルトサイズ
      };     

      /**
       * カテゴリに応じたアイコン取得
       * @param {String} cat - カテゴリ名
       * @returns {Object} - Leafletアイコン
       */
      function getCategoryIcon(cat) {
          const size = categoryIconSizes[cat.toLowerCase()] || categoryIconSizes['default'];
          return L.icon({
              iconUrl: chooseCategoryIconUrl(cat),
              iconSize: size, // カテゴリーごとのサイズを適用
              iconAnchor: [size[0] / 2, size[1] / 2], // アイコンのアンカーを中央に設定
              popupAnchor: [0, -size[1] / 2]
          });
      }

      /**
       * アイコンURL選択関数
       * @param {String} cat - カテゴリ名
       * @returns {String} - アイコンのURL
       */
      function chooseCategoryIconUrl(cat) {
          switch (cat.toLowerCase()) {
              case 'primary':      return 'https://img.icons8.com/?size=100&id=bnfp2fmtrh0g&format=png&color=571601B8';
              case 'area':         return 'https://img.icons8.com/?size=100&id=bnfp2fmtrh0g&format=png&color=1A529300'; /*透明=非表示*/
              case 'haseko':       return 'https://img.icons8.com/?size=100&id=uRRFz0DH6uYw&format=png&color=000000';
              case 'ecoba':        return 'https://img.icons8.com/?size=100&id=59830&format=png&color=4BAA8EA8';
              case 'condominium':  return 'https://img.icons8.com/?size=30&id=24801&format=png&color=FF2E1754';
              case 'others':       return 'https://img.icons8.com/?size=100&id=bnfp2fmtrh0g&format=png&color=0046b099';
              case 'pj site':      return 'https://img.icons8.com/?size=100&id=ipgAkdE46kxu&format=png&color=000000';
              default:             return 'https://maps.google.com/mapfiles/ms/icons/black-dot.png';
          }
      }

      /**
       * ポリゴン作成関数
       * @param {Object} item - 物件データ
       * @param {Array} coords - ポリゴンの座標
       * @returns {Object} - Leafletポリゴン
       */
      function createPolygonWithCategoryStyle(item, coords) {
        const polygonStyle = getCategoryPolygonStyle(item.category1);
        const polygon = L.polygon(coords, polygonStyle).addTo(map);
        polygon.bindPopup(buildPopup(item));
        polygon.on('click', () => polygon.openPopup());
        return polygon;
      }

      /**
       * カテゴリに応じたポリゴンスタイル取得
       * @param {String} cat - カテゴリ名
       * @returns {Object} - ポリゴンスタイル
       */
      function getCategoryPolygonStyle(cat) {
        switch (cat.toLowerCase()) {
          case 'primary':      return { color: 'none', fillColor: 'blue', fillOpacity: 0.2 };
          case 'area':         return { color: 'none', fillColor: 'gold', fillOpacity: 0.2 };
          case 'haseko':       return { color: 'none', fillColor: 'orange', fillOpacity: 0.2 };
          case 'ecoba':        return { color: 'none', fillColor: 'purple', fillOpacity: 0.2 };
          case 'condominium':  return { color: 'none', fillColor: 'red', fillOpacity: 0.2 };
          case 'others':       return { color: 'none', fillColor: 'yellow', fillOpacity: 0.2 };
          case 'pj site':      return { color: 'none', fillColor: 'grey', fillOpacity: 0.2 };
          default:             return { color: 'none', fillColor: 'black', fillOpacity: 0.2 };
        }
      }

      /**
       * アイテムにズーム
       * @param {Object} item - 物件データ
       */
      function zoomToItem(item) {
          // ポリゴン（siteArea）がある場合の処理
          if (item.siteArea) {
              try {
                  const coords = JSON.parse(item.siteArea);
                  if (Array.isArray(coords) && coords.length >= 3) {
                      const tempPoly = L.polygon(coords);
                      map.fitBounds(tempPoly.getBounds(), { padding: [20, 20] });
                      return; // ポリゴンが存在する場合はここで処理終了
                  }
              } catch (e) {
                  console.warn("Invalid siteArea format:", e);
              }
          }

          // 緯度・経度が有効な場合の処理
          if (!isNaN(item.latitude) && !isNaN(item.longitude)) {
              const targetLatLng = [item.latitude, item.longitude];
              const zoomLevel = 17; // ズームレベルを変更可能

              // アニメーション付きズーム（flyToを利用）
              map.flyTo(targetLatLng, zoomLevel);
          } else {
              console.warn("Invalid coordinates for item:", item);
          }
      }

      /**
       * ポップアップ内容構築
       * @param {Object} item - 物件データ
       * @returns {String} - HTMLコンテンツ
       */
      function buildPopup(item) {
        return `
          <strong>${item.pjName}</strong><br>
          Address: ${item.address}<br>
          Category1: ${item.category1}<br>
          Category2: ${item.category2}<br>
          Developer: ${item.developer}<br>
          Architect: ${item.architect}<br>
          Contractor: ${item.contractor}<br>
          Sales Company: ${item.salesCompany}<br>
          Status: ${item.status}<br>
        `;
      }

      // -------------------------------------------------------
      // 5) Show/Hide List
      // -------------------------------------------------------
      /**
       * リスト表示の切り替え関数
       */
      function toggleList() {
        const listArea = document.getElementById('propertyListArea');
        const toggleIcon = document.getElementById('toggleIcon');  // アイコンを取得

        if (listArea.classList.contains('hidden')) {
            listArea.classList.remove('hidden');
            toggleIcon.classList.remove('fa-angles-down');  // "down"アイコンを削除
            toggleIcon.classList.add('fa-angles-up');   // "up"アイコンを追加
        } else {
            listArea.classList.add('hidden');
            toggleIcon.classList.remove('fa-angles-up');  // "up"アイコンを削除
            toggleIcon.classList.add('fa-angles-down');       // "down"アイコンを追加
        }
      }

      // -------------------------------------------------------
      // 6) Simple Search
      // -------------------------------------------------------
      /**
       * 簡易検索関数
       * @param {Array} data - 物件データ
       * @param {String} rawQuery - ユーザーのクエリ
       * @returns {Array} - 検索結果
       */
      function simpleSearch(data, rawQuery) {
        const tokens = rawQuery.toLowerCase().split(/\s+/);
        const notWords = tokens.filter(t => t.startsWith("-")).map(t => t.slice(1));
        const andWords = tokens.filter(t => !t.startsWith("-") && t !== "and" && t !== "or");

        /**
         * アイテムのテキストを構築
         * @param {Object} item - 物件データ
         * @returns {String} - 結合されたテキスト
         */
        function buildText(item) {
          const combined = [
            item.pjName,
            item.address,
            item.category1,
            item.category2,
            item.developer,
            item.architect,
            item.contractor,
            item.salesCompany,
            item.status,
            item.siteArea
          ].join(" ").toLowerCase().replace(/\s+/g, "");
          return combined;
        }

        let idxSet = new Set(data.map((_, i) => i));
        // AND条件
        andWords.forEach(w => {
          idxSet = new Set([...idxSet].filter(idx => {
            const txt = buildText(data[idx]);
            return txt.includes(w);
          }));
        });
        // NOT条件
        notWords.forEach(n => {
          idxSet.forEach(idx => {
            const txt = buildText(data[idx]);
            if (txt.includes(n)) {
              idxSet.delete(idx);
            }
          });
        });
        return [...idxSet].map(i => data[i]);
      }

      // -------------------------------------------------------
      // 7) Complex Search (parentheses, AND/OR/NOT, : = > >=)
      // -------------------------------------------------------
      /**
       * 複雑な検索クエリを解析してフィルタリングする関数
       * @param {String} query - ユーザーのクエリ
       * @param {Array} data - 物件データ
       * @returns {Array} - 検索結果
       */
      function parseComplexQuery(query, data) {
        const tokens = tokenizeComplex(query);
        const ast = parseExpression(tokens);
        if (tokens.length > 0) {
          throw new Error("Extra tokens remain. Check parentheses or operators.");
        }
        return data.filter(item => evaluateAST(ast, item));
      }

      /**
       * クエリをトークンに分解する関数
       * @param {String} q - クエリ文字列
       * @returns {Array} - トークンの配列
       */
      function tokenizeComplex(q) {
        const pattern = /\(|\)|\bAND\b|\bOR\b|\bNOT\b|>=|>|=|:|"[^"]*"|\S+/gi;
        const raw = q.match(pattern) || [];
        const tokens = [];
        raw.forEach(t => {
          const upper = t.toUpperCase();
          if (upper === 'AND' || upper === 'OR' || upper === 'NOT'
           || t === '(' || t === ')' || t === '>' || t === '>='
           || t === '=' || t === ':') {
            tokens.push({ type: upper, text: t });
          } else if (t.startsWith('"') && t.endsWith('"')) {
            tokens.push({ type: 'STRING', text: t.slice(1, -1) });
          } else {
            tokens.push({ type: 'WORD', text: t });
          }
        });
        return tokens;
      }

      /**
       * 式を解析する関数
       * @param {Array} tokens - トークンの配列
       * @returns {Object} - 抽象構文木（AST）
       */
      function parseExpression(tokens) {
        let left = parseTerm(tokens);
        while (peek(tokens, 'OR')) {
          consume(tokens, 'OR');
          const right = parseTerm(tokens);
          left = { type: 'OR', left, right };
        }
        return left;
      }

      function parseTerm(tokens) {
        let left = parseFactor(tokens);
        while (peek(tokens, 'AND')) {
          consume(tokens, 'AND');
          const right = parseFactor(tokens);
          left = { type: 'AND', left, right };
        }
        return left;
      }

      function parseFactor(tokens) {
        let isNot = false;
        if (peek(tokens, 'NOT')) {
          consume(tokens, 'NOT');
          isNot = true;
        }
        let node;
        if (peek(tokens, '(')) {
          consume(tokens, '(');
          node = parseExpression(tokens);
          consume(tokens, ')');
        } else {
          node = parseCondition(tokens);
        }
        if (isNot) {
          node = { type: 'NOT', expr: node };
        }
        return node;
      }

      function parseCondition(tokens) {
        const colToken = consumeType(tokens, ['WORD']);
        const opToken = nextToken(tokens);
        if (![':', '=', '>', '>='].includes(opToken.text)) {
          throw new Error(`Invalid operator: ${opToken.text}`);
        }
        const valToken = consumeType(tokens, ['WORD','STRING']);
        return {
          type: 'COND',
          column: colToken.text,
          op: opToken.text,
          value: valToken.text
        };
      }

      function peek(tokens, text) {
        return tokens[0] && tokens[0].text.toUpperCase() === text.toUpperCase();
      }

      function consume(tokens, text) {
        if (!peek(tokens, text)) {
          throw new Error(`Expected "${text}" but got "${tokens[0]?.text}"`);
        }
        return tokens.shift();
      }

      function consumeType(tokens, types) {
        if (!tokens[0] || !types.includes(tokens[0].type)) {
          throw new Error(`Expected one of [${types.join(', ')}], got ${tokens[0]?.type}`);
        }
        return tokens.shift();
      }

      function nextToken(tokens) {
        if (!tokens.length) throw new Error("Unexpected end of tokens.");
        return tokens.shift();
      }

      /**
       * 抽象構文木（AST）を評価する関数
       * @param {Object} ast - 抽象構文木
       * @param {Object} item - 物件データ
       * @returns {Boolean} - 評価結果
       */
      function evaluateAST(ast, item) {
        switch (ast.type) {
          case 'OR':
            return evaluateAST(ast.left, item) || evaluateAST(ast.right, item);
          case 'AND':
            return evaluateAST(ast.left, item) && evaluateAST(ast.right, item);
          case 'NOT':
            return !evaluateAST(ast.expr, item);
          case 'COND':
            return evaluateCondition(ast, item);
          default:
            throw new Error("Unknown AST node type: " + ast.type);
        }
      }

      /**
       * 条件を評価する関数
       * @param {Object} cond - 条件オブジェクト
       * @param {Object} item - 物件データ
       * @returns {Boolean} - 評価結果
       */
      function evaluateCondition(cond, item) {
        const col = cond.column.toLowerCase();
        const op  = cond.op;
        const val = cond.value;
        let fieldVal = (item[col] || "").toString().toLowerCase();
        let fieldNum = parseFloat(item[col]);

        switch (op) {
          case ':':
            return fieldVal.includes(val.toLowerCase());
          case '=':
            return fieldVal === val.toLowerCase();
          case '>':
          case '>=': {
            if (isNaN(fieldNum)) return false;
            const cmp = parseFloat(val);
            if (isNaN(cmp)) return false;
            return (op === '>') ? (fieldNum > cmp) : (fieldNum >= cmp);
          }
          default:
            return false;
        }
      }

      // -------------------------------------------------------
      // 8) handleGeoSearch (Nominatim)
      // -------------------------------------------------------
      let boundaryLayer = null;
      let maskLayer = null;

      const geoSearchBox = document.getElementById('geoSearchBox');

      geoSearchBox.addEventListener('keydown', async (event) => {
          if (event.key === 'Enter') {
              await handleGeoSearch();
          }
      });

      /**
       * 地域検索処理
       */
      async function handleGeoSearch() {
        const q = geoSearchBox.value.trim();
        if (!q) {
          alert("Please enter a place name.");
          return;
        }

        closeUIElements();

        try {
          // ローディングスピナーを表示
          showLoadingSpinner('geoLoadingSpinner');

          // 既存のレイヤーを削除
          if (boundaryLayer) map.removeLayer(boundaryLayer);
          if (maskLayer) map.removeLayer(maskLayer);

          // Nominatim APIを使用して地理情報を取得
          const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}&polygon_geojson=1`;
          const response = await fetch(url);
          if (!response.ok) throw new Error("Network response was not ok.");
          const data = await response.json();

          if (!data.length) {
            alert("No matching location found.");
            return;
          }

          const result = data[0];

          if (result.geojson) {
            // 境界線を描画
            boundaryLayer = L.geoJSON(result.geojson, {
              style: {
                color: '#FF000DA8',
                weight: 1.7,
                opacity: 1,
                fillOpacity: 0,
                dashArray: '2, 3'
              }
            }).addTo(map);

            // マスクレイヤーを作成　（アジア中心）
            const mapBounds = map.getBounds();
            const worldBounds = [
              [
                [-90, 360],   // 最南端, 東端
                [90, 360],    // 最北端, 東端
                [90, -360],   // 最北端, 西端
                [-90, -360],  // 最南端, 西端
                [-90, 360]    // 多角形を閉じる
              ]
            ];

            if (result.geojson.type === 'Polygon') {
              worldBounds.push(result.geojson.coordinates[0].map(p => [p[1], p[0]]).reverse());
            } else if (result.geojson.type === 'MultiPolygon') {
              result.geojson.coordinates.forEach(poly => {
                worldBounds.push(poly[0].map(p => [p[1], p[0]]).reverse());
              });
            }

            maskLayer = L.polygon(worldBounds, {
              color: 'none',
              fillColor: '#000',
              fillOpacity: 0.1
            }).addTo(map);
            maskLayer.bringToBack();

            // 地図を境界に合わせる
            map.fitBounds(boundaryLayer.getBounds(), { padding: [20, 20] });
          } else {
            // 境界がない場合は中心点に移動
            map.setView([result.lat, result.lon], 13);
          }

        } catch(e) {
          console.error(e);
          alert("Search failed. Please try again.");
        } finally {
          // ローディングスピナーを非表示
          hideLoadingSpinner('geoLoadingSpinner');
        }
      }

      /**
       * 地理検索ボックスをクリアする関数
       */
      function clearGeoSearch() {
        geoSearchBox.value = '';

        // 検索結果をクリアする（既存の地理検索結果レイヤーを削除）
        if (boundaryLayer) {
          map.removeLayer(boundaryLayer);
          boundaryLayer = null;
        }
        if (maskLayer) {
          map.removeLayer(maskLayer);
          maskLayer = null;
        }
      }

      /**
       * 物件検索ボックスをクリアする関数
       */
      function clearPropertySearch() {
        propertySearchBox.value = '';

        // 検索結果をクリアする（マーカーとポリゴンを削除）
        propertyMarkers.forEach(marker => map.removeLayer(marker));
        propertyMarkers.length = 0;

        propertyPolygons.forEach(polygon => map.removeLayer(polygon));
        propertyPolygons.length = 0;

        const ul = document.getElementById('propertyResultUl');
        ul.innerHTML = "";
      }

      // -------------------------------------------------------
      // **) Close UI Elements
      // -------------------------------------------------------
      /**
       * UI要素を閉じる関数
       */
      function closeUIElements() {
        const menuContainer = document.getElementById('menuContainer');
        const listArea = document.getElementById('propertyListArea');
        const mapElement = document.getElementById('map');

        // 携帯表示（モバイル用クラス）
        if (window.innerWidth < 769) {
            if (menuContainer) {
                menuContainer.classList.remove('full', 'half');
                menuContainer.classList.add('closed'); // スライドダウン
            }
        } 
        // PC表示（スタイル変更）
        else {
            if (menuContainer) {
                menuContainer.style.transform = 'translateX(-320px)'; // メニューを隠す
            }
        }

        // 物件リストを非表示にする
        if (listArea) {
            listArea.classList.add('hidden');
        }

        // モバイルキーボードを閉じる
        document.activeElement.blur();

        // 地図にフォーカスを移動
        if (mapElement) {
            mapElement.focus();
        }
      }

      // -------------------------------------------------------
      // 9) Real-time Current Location
      // -------------------------------------------------------
      let currentLocMarker = null;
      let watchID = null;
      let trackingActive = false;

      const currentLocationBtn = document.getElementById('currentLocationBtn');

      currentLocationBtn.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          toggleCurrentLocation();
        }
      });

      /**
       * 現在位置の追跡を切り替える関数
       */
      function toggleCurrentLocation() {
        const btnIcon = document.querySelector('#currentLocationBtn img'); // ボタン内のアイコン画像を取得

        if (!trackingActive) {
            // リアルタイム追跡を開始
            if (!navigator.geolocation) {
              alert("Geolocation is not supported by this browser.");
              return;
            }
            watchID = navigator.geolocation.watchPosition(
              positionSuccess,
              positionError,
              { enableHighAccuracy: true }
            );
            btnIcon.src = "https://img.icons8.com/?size=100&id=ziC1TV1ikKi9&format=png&color=004ACD99"; // 追跡中のアイコン
            btnIcon.alt = "Tracking Current Location";
            trackingActive = true;
        } else {
            // リアルタイム追跡を停止
            if (watchID !== null) {
              navigator.geolocation.clearWatch(watchID);
              watchID = null;
            }
            if (currentLocMarker) {
              map.removeLayer(currentLocMarker);
              currentLocMarker = null;
            }
            btnIcon.src = "https://img.icons8.com/?size=100&id=ziC1TV1ikKi9&format=png&color=004ACD63"; // 停止中のアイコン
            btnIcon.alt = "Stop Tracking Location";
            trackingActive = false;
        }
      }

      /**
       * 現在位置取得成功時のコールバック
       * @param {Object} pos - GeolocationPositionオブジェクト
       */
      function positionSuccess(pos) {
        const lat = pos.coords.latitude;
        const lng = pos.coords.longitude;
        console.log("Current position:", lat, lng);

        // マーカーがまだ作成されていない場合、作成
        if (!currentLocMarker) {
            const divIcon = L.divIcon({
              html: '<div class="blinking-marker"></div>',
              className: '',
              iconSize: [18, 18],
              iconAnchor: [9, 9]
            });
            currentLocMarker = L.marker([lat, lng], { icon: divIcon }).addTo(map);
        } else {
            // 位置を更新
            currentLocMarker.setLatLng([lat, lng]);
        }

        // 現在位置にスムーズに移動
        map.flyTo([lat, lng], 16);
      }

      /**
       * 現在位置取得失敗時のコールバック
       * @param {Object} err - GeolocationPositionErrorオブジェクト
       */
      function positionError(err) {
        console.error("Geolocation error:", err);
        alert("Failed to get current location: " + err.message);
      }

      // -------------------------------------------------------
      // 10) Menu Container 改善
      // -------------------------------------------------------
      document.addEventListener('DOMContentLoaded', () => {
        const menuContainer = document.getElementById('menuContainer');
        const menuToggleBtn = document.getElementById('menuToggleBtn');
        const menuDragHandle = document.getElementById('menuDragHandle');

        // PC用の状態管理
        let isMenuOpen = false;
        let isHovering = false;

        // モバイル用の状態管理
        let startY = 0;
        let isDragging = false;

        // デバイスチェック関数
        const isPCView = () => window.innerWidth >= 769;

        /**
         * メニューの位置を更新する関数
         * @param {Number} position - メニューのX位置
         */
        function updateMenuPosition(position) {
          if (isPCView()) {
            menuContainer.style.transform = `translateX(${position}px)`;
          }
        }

        /**
         * メニュートグルボタンのクリックイベントハンドラ
         * @param {Event} e - クリックイベント
         */
        function handleMenuToggle(e) {
          if (isPCView()) {
            e.stopPropagation();
            isMenuOpen = !isMenuOpen;
            updateMenuPosition(isMenuOpen ? 0 : -320); /* default -280 */
            menuToggleBtn.innerHTML = isMenuOpen ? '&times;' : '☰';
            menuToggleBtn.setAttribute('aria-pressed', isMenuOpen);
          }
        }

        /**
         * メニュー外クリック時にメニューを閉じる関数
         * @param {Event} e - クリックイベント
         */
        function handleDocumentClick(e) {
          if (isPCView() && isMenuOpen && 
              !menuContainer.contains(e.target) && 
              e.target !== menuToggleBtn) {
            isMenuOpen = false;
            updateMenuPosition(-320); /* default -280 */
            menuToggleBtn.innerHTML = '☰';
            menuToggleBtn.setAttribute('aria-pressed', isMenuOpen);
          }
        }

        /**
         * メニューコンテナのホバーイベントハンドラ
         */
        function handleMenuHover() {
          if (isPCView() && !isMenuOpen) {
            isHovering = true;
            updateMenuPosition(-320); /* default -200 */
          }
        }

        /**
         * メニューコンテナのホバー終了イベントハンドラ
         */
        function handleMenuHoverEnd() {
          if (isPCView() && !isMenuOpen) {
            isHovering = false;
            updateMenuPosition(-320); /* default -280 */
          }
        }

        /**
         * メニューコンテナのクリックイベントハンドラ
         * @param {Event} e - クリックイベント
         */
        function handleMenuClick(e) {
          if (isPCView() && !isMenuOpen && isHovering) {
            isMenuOpen = true;
            updateMenuPosition(0);
            menuToggleBtn.innerHTML = '&times;';
            menuToggleBtn.setAttribute('aria-pressed', isMenuOpen);
            e.stopPropagation();
          }
        }

        /**
         * モバイル用のメニュードラッグイベントハンドラ
         * @param {TouchEvent} e - タッチイベント
         */
        function handleMenuDragStart(e) {
          if (!isPCView()) {
            startY = e.touches[0].clientY;
            isDragging = true;
          }
        }

        /**
         * モバイル用のメニュードラッグ移動イベントハンドラ
         * @param {TouchEvent} e - タッチイベント
         */
        function handleMenuDragMove(e) {
          if (!isDragging || isPCView()) return;
          const currentY = e.touches[0].clientY;
          const deltaY = currentY - startY;

          if (deltaY > 50) {
            setMenuState('closed');
          } else if (deltaY > -50 && deltaY < 50) {
            setMenuState('half');
          } else if (deltaY < -50) {
            setMenuState('full');
          }
        }

        /**
         * モバイル用のメニュードラッグ終了イベントハンドラ
         */
        function handleMenuDragEnd() {
          if (!isPCView()) {
            isDragging = false;
          }
        }

        /**
         * メニューの状態を設定する関数
         * @param {String} state - 'closed', 'half', 'full'
         */
        function setMenuState(state) {
          if (!isPCView()) {
            menuContainer.classList.remove('closed', 'half', 'full');
            menuContainer.classList.add(state);
          }
        }

        // メニュートグルボタンにイベントリスナーを追加
        if (menuToggleBtn) {
          menuToggleBtn.addEventListener('click', handleMenuToggle);
          menuToggleBtn.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              handleMenuToggle(e);
            }
          });
        }

        // ドキュメント全体にクリックイベントリスナーを追加
        document.addEventListener('click', handleDocumentClick);

        // メニューコンテナにホバーイベントリスナーを追加
        if (menuContainer) {
          menuContainer.addEventListener('mouseenter', handleMenuHover);
          menuContainer.addEventListener('mouseleave', handleMenuHoverEnd);
          menuContainer.addEventListener('click', handleMenuClick);
        }

        // メニューコンテナにドラッグイベントリスナーを追加
        if (menuDragHandle) {
          menuDragHandle.addEventListener('touchstart', handleMenuDragStart);
          menuDragHandle.addEventListener('touchmove', handleMenuDragMove);
          menuDragHandle.addEventListener('touchend', handleMenuDragEnd);
        }
 

        
        /**
         * Add by Sako
         * 物件リスト外クリックでリスト閉じる
         */        
        // ドキュメント全体のクリックを監視してリストを閉じる
        document.addEventListener('click', (event) => {
          const propertyContainer = document.getElementById('propertyContainer'); // 物件コンテナ
          const propertyListArea = document.getElementById('propertyListArea'); // 物件リスト

          // クリックした箇所が物件コンテナの外で、リストが表示されている場合
          if (!propertyContainer.contains(event.target) && !propertyListArea.classList.contains('hidden')) {
            toggleList(); // 既存のリストを閉じる関数を呼び出す
          }
        });
        
        

        // リサイズイベントに対応
        window.addEventListener('resize', () => {
          if (isPCView()) {
            updateMenuPosition(isMenuOpen ? 0 : -320); /* default -280 */
            menuContainer.classList.remove('closed', 'half', 'full');
          } else {
            menuContainer.style.transform = '';
            menuContainer.classList.add('closed');
            isMenuOpen = false;
            isHovering = false;
          }
        });
      });

      // -------------------------------------------------------
      // 11) Utility Functions
      // -------------------------------------------------------
      /**
       * ローディングスピナーを表示する関数
       * @param {String} spinnerId - スピナーのID
       */
      function showLoadingSpinner(spinnerId) {
        const spinner = document.getElementById(spinnerId);
        if (spinner) {
          spinner.classList.add('loading');
          spinner.setAttribute('aria-hidden', 'false');
        }
      }

      /**
       * ローディングスピナーを非表示にする関数
       * @param {String} spinnerId - スピナーのID
       */
      function hideLoadingSpinner(spinnerId) {
        const spinner = document.getElementById(spinnerId);
        if (spinner) {
          spinner.classList.remove('loading');
          spinner.setAttribute('aria-hidden', 'true');
        }
      }

      // -------------------------------------------------------
      // 12) Expose Functions to Global Scope
      // -------------------------------------------------------
      // これらの関数をグローバルスコープに公開する
      window.clearGeoSearch = clearGeoSearch;
      window.clearPropertySearch = clearPropertySearch;
      window.toggleCurrentLocation = toggleCurrentLocation;
      window.toggleList = toggleList;
      window.openInfoModal = openInfoModal;
      window.closeInfoModal = closeInfoModal;
      window.openTab = openTab;
      
      // -------------------------------------------------------
      // 13) Custom Zoom Controls
      // -------------------------------------------------------
      (() => {
        // Ensure the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
          // Select Zoom Controls Elements
          const zoomContainer = document.getElementById('zoomContainer');
          const moveZoomBtn = document.getElementById('moveZoomBtn');
          const zoomInBtn = document.getElementById('zoomInBtn');
          const zoomOutBtn = document.getElementById('zoomOutBtn');

          // Track the current position: true = right, false = left
          let isRight = true;

          // Function to toggle zoom container position
          function toggleZoomPosition() {
            if (isRight) {
              // Move to left
              zoomContainer.classList.add('moved-left');
              zoomContainer.classList.remove('moved-right');
              moveZoomBtn.innerHTML = '<i class="fa-solid fa-caret-right"></i>';
            } else {
              // Move to right
              zoomContainer.classList.remove('moved-left');
              zoomContainer.classList.add('moved-right');
              moveZoomBtn.innerHTML = '<i class="fa-solid fa-caret-left"></i>';
            }
            isRight = !isRight;
          }

          // Event Listener for Move Button
          moveZoomBtn.addEventListener('click', toggleZoomPosition);
          moveZoomBtn.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              toggleZoomPosition();
            }
          });

          // Event Listener for Zoom In Button
          zoomInBtn.addEventListener('click', () => {
            map.zoomIn();
          });
          zoomInBtn.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              map.zoomIn();
            }
          });

          // Event Listener for Zoom Out Button
          zoomOutBtn.addEventListener('click', () => {
            map.zoomOut();
          });
          zoomOutBtn.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              map.zoomOut();
            }
          });

          // Optional: Keyboard shortcuts for zooming
          map.on('keydown', (e) => {
            if (e.key === '+') {
              map.zoomIn();
            } else if (e.key === '-') {
              map.zoomOut();
            }
          });
        });
      })();
  

      // -------------------------------------------------------
      // 14) Modal Control Functions
      // -------------------------------------------------------
      /**
       * Opens the Info Modal
       */
      function openInfoModal() {
        const modal = document.getElementById('infoContainer');
        if (modal) {
          modal.style.display = 'block';
          modal.setAttribute('aria-hidden', 'false');
          
          // Optionally, set focus to the modal for accessibility
          const closeButton = modal.querySelector('.close-button');
          if (closeButton) closeButton.focus();
          
          // Add event listener for Escape key to close modal
          document.addEventListener('keydown', handleEscapeKey);
        }
      }

      /**
       * Closes the Info Modal
       */
      function closeInfoModal() {
        const modal = document.getElementById('infoContainer');
        if (modal) {
          modal.style.display = 'none';
          modal.setAttribute('aria-hidden', 'true');
          
          // Optionally, return focus to the info-icon for accessibility
          const infoIcon = document.querySelector('.info-icon');
          if (infoIcon) infoIcon.focus();
          
          // Remove event listener for Escape key
          document.removeEventListener('keydown', handleEscapeKey);
        }
      }

      /**
       * Handles tab switching within the modal
       * @param {String} tabName - The ID of the tab to open
       */
      function openTab(tabName) {
        const tabs = document.querySelectorAll('.tab-button');
        const panels = document.querySelectorAll('.tab-panel');

        tabs.forEach(tab => {
          if (tab.getAttribute('onclick') === `openTab('${tabName}')`) {
            tab.classList.add('active');
          } else {
            tab.classList.remove('active');
          }
        });

        panels.forEach(panel => {
          if (panel.id === tabName) {
            panel.classList.add('active');
          } else {
            panel.classList.remove('active');
          }
        });
      }

      /**
       * Handles closing the modal when the Escape key is pressed
       * @param {KeyboardEvent} event 
       */
      function handleEscapeKey(event) {
        if (event.key === 'Escape') {
          closeInfoModal();
        }
      }

      /**
       * Initializes modal event listeners
       */
      function initializeModal() {
        const modal = document.getElementById('infoContainer');
        if (modal) {
          // Close modal when clicking outside the modal content
          window.addEventListener('click', function(event) {
            if (event.target === modal) {
              closeInfoModal();
            }
          });
        }
      }

      // Initialize modal functionalities when DOM is fully loaded
      document.addEventListener('DOMContentLoaded', initializeModal);      

    })();
  </script>
</body>
</html>
