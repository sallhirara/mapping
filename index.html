<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, viewport-fit=cover">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Project Map</title>

  <!-- Font Awesome CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

  <!-- Leaflet CSS / JS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- XLSX for reading .xls / .xlsx / .xlsm -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <style>
    /* 基本リセット */
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    /* 全体レイアウト */
    body {
      font-family: Arial, sans-serif;
      height: 100vh;
      overflow: hidden; 
      display: flex;
      flex-direction: column;
    }

    /* 共通メニュースタイル */
    .menu {
      position: fixed;
      background: rgba(255, 255, 255, 0.95);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      transition: transform 0.3s ease-in-out;
      z-index: 1000;
    }

    /* メディアクエリ: モバイル */
    @media screen and (max-width: 768px) {
      /* メニューコンテナのスタイル */
      #menuContainer {
        position: fixed;
        bottom: -66%;
        left: 0;
        width: 100%;
        height: 70%;
        border-radius: 15px 15px 0 0;
        background: rgba(255, 255, 255, 0.95);
        transition: transform 0.3s ease-out, bottom 0.3s ease-out;
        z-index: 1000;
      }

      /* メニューの状態 */
      #menuContainer.closed { bottom: -66%; }
      #menuContainer.half { bottom: -30%; }
      #menuContainer.full { bottom: 0; }

      /* ドラッグハンドル */
      .menu-header {
        width: 100%;
        height: 30px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 15px 15px 0 0;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: grab;
      }

      .drag-handle {
        width: 50px;
        height: 5px;
        background: #999;
        border-radius: 2.5px;
      }

      /* メニュートグルボタンを非表示に */
      .menu-toggle { display: none !important; }
    }

    /* メディアクエリ: デスクトップ/タブレット */
    @media screen and (min-width: 769px) {
      #menuContainer {
        top: 0;
        left: 0;
        width: 320px;
        height: 100%;
        border-radius: 0 15px 15px 0;
        transform: translateX(-280px);
        transition: transform 0.3s ease-out;
      }

      #menuContainer.open { transform: translateX(0); }

      /* メニュートグルボタンのスタイル */
      .menu-toggle {
        position: absolute;
        top: 50%;
        right: -30px;
        transform: translateY(-50%);
        background: white;
        color: #666;
        border: 1px solid #ccc;
        border-radius: 0 5px 5px 0;
        padding: 8px 12px;
        cursor: pointer;
        box-shadow: 2px 0 5px rgba(0,0,0,0.1);
        z-index: 1001;
        transition: color 0.3s;
      }

      .menu-toggle:hover { color: #333; }

      /* メニューコンテンツ */
      .menu-content {
        width: 100%;
        height: 100%;
        background: white;
        overflow-y: auto;
        padding: 10px;
      }

      /* PCではメニューヘッダーを非表示 */
      .menu-header { display: none !important; }
    }

    /* その他のスタイル */
    #top-bar {
      background: #f8f9fa;
      margin-left: 5px;
      padding: 5px 15px;
      display: flex;
      gap: 10px;
      align-items: center;
    }

    #top-bar input {
        border: 1px solid grey;
        border-radius: 15px;
        padding: 5px 10px;
        font-size: 16px;
    }

    /* 検索コンテナ */
    .search-container {
      position: relative;
      display: inline-block;
    }

    .search-container input {
      padding-right: 30px;
      font-size: 16px;
    }

    .clear-icon {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      width: 20px;
      height: 20px;
      cursor: pointer;
      display: none;
      opacity: 0.7;
      transition: opacity 0.3s, transform 0.3s;
    }

    .clear-icon:hover {
      opacity: 1;
      transform: scale(1.2);
    }

    .search-container input:not(:placeholder-shown) + .clear-icon {
      display: block;
    }

    /* カスタムファイル入力 */
    .custom-file-input {
        color: #333;
        font-size: 20px;
        margin-right: 0px;
        display: inline-block;
        padding: 4px 12px;
        cursor: pointer;
        border-radius: 8px;
        transition: background-color 0.3s;
    }

    .custom-file-input:hover {
        background-color: #ddd;
    }

    #fileInput { display: none; }

    /* 地図スタイル */
    #map {
      flex: 1;
      position: relative;
      height: calc(100% + 0px);
      width: 100%;
      z-index: 0;
    }

    /* ボタンスタイル */
    #currentLocationBtn, #layerToggleBtn {
        position: fixed;
        z-index: 1000;
        cursor: pointer;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.3s ease;
        background: white;
        border: none;
    }

    #currentLocationBtn {
        top: 50px;
        right: 15px;
    }

    #layerToggleBtn {
        top: 15px;
        right: 15px;
    }

    #currentLocationBtn:hover, #layerToggleBtn:hover {
        transform: scale(1.2);
    }

    #currentLocationBtn img, #layerToggleBtn img {
        width: 25px;
        height: 25px;
    }

    /* 物件コンテナ */
    #propertyContainer {
      position: fixed;
      top: 15px; 
      width: 320px;
      max-height: 70vh; 
      background-color: transparent;
      z-index: 999;
      border: 0px solid #ccc;
      border-radius: 15px;
      display: flex;
      flex-direction: column;
      pointer-events: auto;
      touch-action: pan-y; 
      overscroll-behavior: contain;
      /* ローディングインジケーター用 */
      position: relative;
    }

    /* モバイル用 */
    #propertyContainer { left: 15px; }

    /* デスクトップ用 */
    @media screen and (min-width: 769px) {
      #propertyContainer { left: 60px; }
    }

    #propertySearchHeader {
      background: transparent;
      padding: 5px;
      display: flex;
      gap: 5px;
      flex-wrap: wrap;
      align-items: center;
    }

    #propertySearchHeader input {
      flex: 1;
      min-width: 0;
      padding: 5px 10px;
      border: 1px solid grey;
      border-radius: 15px;
      font-size: 16px;
    }

    #propertySearchHeader button {
      padding: 5px 10px;
      cursor: pointer;
      background: none;
      border: none;
      color: #555;
      transition: color 0.3s;
      font-size: 18px;
    }

    #propertySearchHeader button:hover {
      color: #333;
    }

    /* ローディングスピナー */
    .loading-spinner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border: 8px solid #f3f3f3;
      border-top: 8px solid #3498db;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 2s linear infinite;
      z-index: 1001;
      display: none; /* 初期状態では非表示 */
    }

    @keyframes spin {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }

    #propertyListArea {
      flex: 1;
      overflow-y: auto;
      padding: 5px 10px;
      border: none;
      border-radius: 15px;
      background: rgba(255, 255, 255, 0.3);
      backdrop-filter: blur(5px);
      transition: all 0.3s ease;
    }

    #propertyListArea.hidden { display: none; }

    ul { list-style: none; margin: 0; padding: 0; }

    li { border-bottom: 1px solid #ccc; padding: 3px 0; }

    li:last-child { border-bottom: none; }

    .property-name {
      color: #007bff;
      text-decoration: underline;
      cursor: pointer;
    }

    .property-name:hover { color: #0056b3; }

    /* ブリンキングマーカー */
    @keyframes blink {
      0%   { opacity:1; }
      50%  { opacity:0; }
      100% { opacity:1; }
    }

    .blinking-marker {
      width: 14px;
      height: 14px;
      background-color: magenta;
      border: 2px solid white;
      border-radius: 50%;
      animation: blink 1s infinite;
    }

    /* ローディングスピナーの表示 */
    .loading {
      display: block;
    }
  </style>
</head>

<body>
  <!-- 地図コンテナ -->
  <div id="map" tabindex="0" aria-label="Map Area">
    <!-- 現在位置ボタン -->
    <button id="currentLocationBtn" onclick="toggleCurrentLocation()" aria-label="Toggle Current Location" title="Toggle Current Location">
        <img src="https://img.icons8.com/?size=100&id=ziC1TV1ikKi9&format=png&color=004ACD4D" alt="Show Location" />
    </button>

    <!-- 物件コンテナ（検索ボックスとリスト） -->
    <div id="propertyContainer">
      <div id="propertySearchHeader">
        <!-- 物件検索ボックス -->
        <div class="search-container">
          <input
            type="text"
            id="propertySearchBox"
            placeholder="Property search"
            aria-label="Property Search Box"
          />
          <img
            src="https://img.icons8.com/?size=100&id=121477&format=png&color=75750357"
            alt="Clear"
            class="clear-icon"
            onclick="clearPropertySearch()"
            aria-label="Clear Property Search"
          />
        </div>
        <!-- リスト表示トグルボタン -->
        <button onclick="toggleList()" aria-label="Toggle Property List" title="Toggle Property List">
          <i id="toggleIcon" class="fa-solid fa-angles-up" style="color: #555"></i>
        </button>        
      </div>

      <!-- ローディングスピナー -->
      <div class="loading-spinner" id="propertyLoadingSpinner" aria-hidden="true"></div>

      <div id="propertyListArea">
        <ul id="propertyResultUl"></ul>
      </div>
    </div>

    <!-- レイヤートグルボタン -->
    <button id="layerToggleBtn" role="button" aria-label="Toggle Map Layer" title="Toggle Map Layer">
        <img src="https://img.icons8.com/?size=100&id=2m4kkop8aUO5&format=png&color=000000" alt="Toggle Layer Icon" />
    </button>

    <!-- ローディングスピナー（地理検索用） -->
    <div class="loading-spinner" id="geoLoadingSpinner" aria-hidden="true"></div>
  </div>

  <!-- メニューコンテナ -->
  <div id="menuContainer" class="menu" role="navigation" aria-label="Main Menu">
    <div class="menu-header" id="menuDragHandle">
      <div class="drag-handle" aria-hidden="true"></div>
    </div>
    <div class="menu-content">
      <div id="top-bar">
        <!-- 地域検索ボックス -->
        <div class="search-container">
          <input
            type="text"
            id="geoSearchBox"
            placeholder="Enter a place"
            aria-label="Geographical Search Box"
          />
          <img
            src="https://img.icons8.com/?size=100&id=121477&format=png&color=75750357"
            alt="Clear"
            class="clear-icon"
            onclick="clearGeoSearch()"
            aria-label="Clear Geographical Search"
          />
        </div>
        <!-- ファイル入力 -->
        <label for="fileInput" class="custom-file-input" tabindex="0" aria-label="Upload Excel File">
          <i class="fa-solid fa-file-arrow-down"></i>
        </label>
        <input type="file" id="fileInput" accept=".xls,.xlsx,.xlsm" aria-hidden="true" />
      </div>      
      <ul>
        <li><a href="#option1" tabindex="0">Option 1</a></li>
        <li><a href="#option2" tabindex="0">Option 2</a></li>
        <li><a href="#option3" tabindex="0">Option 3</a></li>
      </ul>
    </div>
  </div>

  <!-- メニュートグルボタン -->
  <button id="menuToggleBtn" class="menu-toggle" aria-label="Toggle Menu" title="Toggle Menu">☰</button>

  <script type="module">
    // JavaScriptモジュールの開始
    (() => {
      // -------------------------------------------------------
      // 1) Initialize Leaflet map
      // -------------------------------------------------------
      const map = L.map('map', {
          zoomControl: false, // ズームボタンを非表示にする
          minZoom: 2, // 最小ズームレベルを制限
          maxZoom: 18, // 最大ズームレベルを制限  
          worldCopyJump: true
      }).setView([20, 0], 2);

      // ダブルクリックズームを無効化
      map.doubleClickZoom.disable();

      // ダブルクリック時にパン
      map.on('dblclick', (e) => {
        map.panTo(e.latlng, { animate: true });
      });

      // タイルレイヤーの追加
      const streetLayer = L.tileLayer('https://api.maptiler.com/maps/basic/{z}/{x}/{y}.png?key=Sv80uSRLZxFEwRiW17Cg', {
        maxZoom: 19,
        attribution: '&copy; MapTiler &copy; OpenStreetMap contributors',
        detectRetina: true
      });

      const satelliteLayer = L.tileLayer('https://api.maptiler.com/maps/satellite/{z}/{x}/{y}.jpg?key=Sv80uSRLZxFEwRiW17Cg', {
        maxZoom: 18,
        attribution: '&copy; MapTiler & OpenStreetMap contributors'
      });

      // 初期レイヤーを地図に追加
      streetLayer.addTo(map);

      let isSatellite = false; // 現在のレイヤーフラグ

      // レイヤートグルボタンのクリックイベント
      const toggleBtn = document.getElementById('layerToggleBtn');
      toggleBtn.addEventListener('click', () => {
        toggleMapLayer();
      });

      // レイヤートグルボタンのキーボードイベント
      toggleBtn.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          toggleMapLayer();
        }
      });

      /**
       * マップレイヤーの切り替え関数
       */
      function toggleMapLayer() {
        if (isSatellite) {
            map.removeLayer(satelliteLayer);
            map.addLayer(streetLayer);
            toggleBtn.querySelector('img').src = "https://img.icons8.com/?size=100&id=2m4kkop8aUO5&format=png&color=000000"; // ストリートアイコン
            toggleBtn.querySelector('img').alt = "Switch to Satellite View";
        } else {
            map.removeLayer(streetLayer);
            map.addLayer(satelliteLayer);
            toggleBtn.querySelector('img').src = "https://img.icons8.com/?size=100&id=NHtRhybXwxli&format=png&color=000000"; // 衛星アイコン
            toggleBtn.querySelector('img').alt = "Switch to Street View";
        }
        isSatellite = !isSatellite; // 状態を切り替える
      }

      // 地図の操作を有効化
      map.dragging.enable();
      map.scrollWheelZoom.enable();

      // プロパティコンテナへのポインタ/タッチイベントで地図操作を無効化
      const propertyPanel = document.getElementById('propertyContainer');
      propertyPanel.addEventListener('pointerenter', () => {
        map.dragging.disable();
        map.scrollWheelZoom.disable();
      });
      propertyPanel.addEventListener('pointerleave', () => {
        map.dragging.enable();
        map.scrollWheelZoom.enable();
      });
      propertyPanel.addEventListener('touchstart', () => {
        map.dragging.disable();
        map.scrollWheelZoom.disable();
      });
      propertyPanel.addEventListener('touchend', () => {
        map.dragging.enable();
        map.scrollWheelZoom.enable();
      });

      // -------------------------------------------------------
      // 2) Excel reading (all columns)
      // -------------------------------------------------------
      let propertyData = [];
      const fileInput = document.getElementById('fileInput');

      fileInput.addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (!file) return;

        try {
          // ローディングスピナーを表示
          showLoadingSpinner('propertyLoadingSpinner');

          const data = await readExcelFile(file);
          propertyData = parseExcelData(data);

          console.log("Excel loaded:", propertyData.length, "rows");
          alert("Excel loaded: " + propertyData.length + " properties found.");
        } catch (error) {
          console.error("Error loading Excel file:", error);
          alert("Failed to load Excel file. Please ensure the file is valid.");
        } finally {
          // ローディングスピナーを非表示
          hideLoadingSpinner('propertyLoadingSpinner');
        }
      });

      /**
       * Excelファイルを読み込む非同期関数
       * @param {File} file - ユーザーがアップロードしたファイル
       * @returns {Promise} - Excelデータの配列
       */
      async function readExcelFile(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const data = new Uint8Array(e.target.result);
              const workbook = XLSX.read(data, { type: 'array' });
              const sheetName = workbook.SheetNames[0];
              const jsonData = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName]);
              resolve(jsonData);
            } catch (error) {
              reject(error);
            }
          };
          reader.onerror = () => {
            reject(new Error("Failed to read the file."));
          };
          reader.readAsArrayBuffer(file);
        });
      }

      /**
       * Excelデータをパースして物件データ配列を作成する関数
       * @param {Array} data - Excelから読み込まれたデータ
       * @returns {Array} - パースされた物件データ
       */
      function parseExcelData(data) {
        return data.map(row => ({
          pjName:       row["PJ name"]        || "",
          address:      row["Address"]        || "",
          category1:    row["Category 1"]     || "",
          category2:    row["Category 2"]     || "",
          developer:    row["Developer"]      || "",
          architect:    row["Architect"]      || "",
          contractor:   row["Contractor"]     || "",
          salesCompany: row["Sales Company"]  || "",
          status:       row["Status"]         || "",
          siteArea:     row["Site Area"]      || "",
          latitude:     parseFloat(row["Latitude"]   || "NaN"),
          longitude:    parseFloat(row["Longitude"]  || "NaN"),
        }));
      }

      // -------------------------------------------------------
      // 3) Arrays for markers & polygons
      // -------------------------------------------------------
      const propertyMarkers = [];
      const propertyPolygons = [];

      // -------------------------------------------------------
      // 4) handlePropertySearch
      // -------------------------------------------------------
      const propertySearchBox = document.getElementById('propertySearchBox');

      propertySearchBox.addEventListener('keydown', async (event) => {
          if (event.key === 'Enter') {
              await handlePropertySearch();
          }
      });

      /**
       * 物件検索処理
       */
      async function handlePropertySearch() {
        const query = propertySearchBox.value.trim();
        if (!query) {
          alert("Please enter a property search query.");
          return;
        }

        closeUIElements();

        try {
          // ローディングスピナーを表示
          showLoadingSpinner('propertyLoadingSpinner');

          // 既存のマーカーとポリゴンを削除
          propertyMarkers.forEach(m => map.removeLayer(m));
          propertyMarkers.length = 0;
          propertyPolygons.forEach(p => map.removeLayer(p));
          propertyPolygons.length = 0;

          const ul = document.getElementById('propertyResultUl');
          ul.innerHTML = "";

          let results = [];
          const complexPattern = /[:=()><]|(AND\b)|(OR\b)|(NOT\b)/i;
          if (complexPattern.test(query)) {
            results = parseComplexQuery(query, propertyData);
          } else {
            results = simpleSearch(propertyData, query);
          }
          if (results.length === 0) {
            alert("No matching properties found.");
            return;
          }

          const searchBounds = L.latLngBounds();

          results.forEach((item) => {
            const li = document.createElement('li');
            const nameSpan = document.createElement('span');
            nameSpan.className = "property-name";
            nameSpan.textContent = item.pjName || "(No Name)";
            nameSpan.onclick = () => zoomToItem(item);
            nameSpan.setAttribute('tabindex', '0');
            nameSpan.setAttribute('role', 'button');
            nameSpan.setAttribute('aria-pressed', 'false');
            nameSpan.addEventListener('keydown', (e) => {
              if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                zoomToItem(item);
              }
            });
            li.appendChild(nameSpan);
            ul.appendChild(li);

            if (!isNaN(item.latitude) && !isNaN(item.longitude)) {
              const marker = createMarkerWithCategoryStyle(item);
              propertyMarkers.push(marker);
              searchBounds.extend(marker.getLatLng());
            }
            if (item.siteArea) {
              try {
                const coords = JSON.parse(item.siteArea);
                if (Array.isArray(coords) && coords.length >= 3) {
                  const polygon = createPolygonWithCategoryStyle(item, coords);
                  propertyPolygons.push(polygon);
                  searchBounds.extend(polygon.getBounds());
                }
              } catch(e) {
                console.warn("Invalid siteArea for", item.pjName, e);
              }
            }
          });

          if (searchBounds.isValid()) {
            map.fitBounds(searchBounds, { padding: [20, 20] });
          }
        } catch (error) {
          console.error("Error during property search:", error);
          alert("An error occurred during the search. Please try again.");
        } finally {
          // ローディングスピナーを非表示
          hideLoadingSpinner('propertyLoadingSpinner');
        }
      }

      /**
       * マーカー作成関数
       * @param {Object} item - 物件データ
       * @returns {Object} - Leafletマーカー
       */
      function createMarkerWithCategoryStyle(item) {
        const latLng = [item.latitude, item.longitude];
        let customIcon = getCategoryIcon(item.category1);

        const marker = L.marker(latLng, { icon: customIcon }).addTo(map);
        marker.bindPopup(buildPopup(item));
        return marker;
      }

      /**
       * カテゴリに応じたアイコン取得
       * @param {String} cat - カテゴリ名
       * @returns {Object} - Leafletアイコン
       */
      function getCategoryIcon(cat) {
        return L.icon({
          iconUrl: chooseCategoryIconUrl(cat),
          iconSize: [20, 20], 
          iconAnchor: [10, 10],
          popupAnchor: [0, -10]
        });
      }

      /**
       * アイコンURL選択
       * @param {String} cat - カテゴリ名
       * @returns {String} - アイコンのURL
       */
      function chooseCategoryIconUrl(cat) {
        switch (cat.toLowerCase()) {
          case 'primary':      return 'https://img.icons8.com/?size=100&id=bnfp2fmtrh0g&format=png&color=571601B8';
          case 'area':         return 'https://img.icons8.com/?size=100&id=bnfp2fmtrh0g&format=png&color=05227AA8';
          case 'haseko':       return 'https://img.icons8.com/?size=100&id=uRRFz0DH6uYw&format=png&color=000000';
          case 'ecoba':        return 'https://img.icons8.com/?size=100&id=59830&format=png&color=4BAA8EA8';
          case 'condominium':  return 'https://img.icons8.com/?size=100&id=24801&format=png&color=FF2E1754';
          case 'others':       return 'https://img.icons8.com/?size=100&id=bnfp2fmtrh0g&format=png&color=0046b099';
          case 'pj site':      return 'https://img.icons8.com/?size=100&id=ipgAkdE46kxu&format=png&color=000000';
          default:             return 'https://maps.google.com/mapfiles/ms/icons/black-dot.png';
        }
      }

      /**
       * ポリゴン作成関数
       * @param {Object} item - 物件データ
       * @param {Array} coords - ポリゴンの座標
       * @returns {Object} - Leafletポリゴン
       */
      function createPolygonWithCategoryStyle(item, coords) {
        const polygonStyle = getCategoryPolygonStyle(item.category1);
        const polygon = L.polygon(coords, polygonStyle).addTo(map);
        polygon.bindPopup(buildPopup(item));
        polygon.on('click', () => polygon.openPopup());
        return polygon;
      }

      /**
       * カテゴリに応じたポリゴンスタイル取得
       * @param {String} cat - カテゴリ名
       * @returns {Object} - ポリゴンスタイル
       */
      function getCategoryPolygonStyle(cat) {
        switch (cat.toLowerCase()) {
          case 'primary':      return { color: 'none', fillColor: 'blue', fillOpacity: 0.2 };
          case 'area':         return { color: 'none', fillColor: 'gold', fillOpacity: 0.2 };
          case 'haseko':       return { color: 'none', fillColor: 'orange', fillOpacity: 0.2 };
          case 'ecoba':        return { color: 'none', fillColor: 'purple', fillOpacity: 0.2 };
          case 'condominium':  return { color: 'none', fillColor: 'red', fillOpacity: 0.2 };
          case 'others':       return { color: 'none', fillColor: 'yellow', fillOpacity: 0.2 };
          case 'pj site':      return { color: 'none', fillColor: 'grey', fillOpacity: 0.2 };
          default:             return { color: 'none', fillColor: 'black', fillOpacity: 0.2 };
        }
      }

      /**
       * アイテムにズーム
       * @param {Object} item - 物件データ
       */
      function zoomToItem(item) {
          // ポリゴン（siteArea）がある場合の処理
          if (item.siteArea) {
              try {
                  const coords = JSON.parse(item.siteArea);
                  if (Array.isArray(coords) && coords.length >= 3) {
                      const tempPoly = L.polygon(coords);
                      map.fitBounds(tempPoly.getBounds(), { padding: [20, 20] });
                      return; // ポリゴンが存在する場合はここで処理終了
                  }
              } catch (e) {
                  console.warn("Invalid siteArea format:", e);
              }
          }

          // 緯度・経度が有効な場合の処理
          if (!isNaN(item.latitude) && !isNaN(item.longitude)) {
              const targetLatLng = [item.latitude, item.longitude];
              const zoomLevel = 17; // ズームレベルを変更可能

              // アニメーション付きズーム（flyToを利用）
              map.flyTo(targetLatLng, zoomLevel);
          } else {
              console.warn("Invalid coordinates for item:", item);
          }
      }

      /**
       * ポップアップ内容構築
       * @param {Object} item - 物件データ
       * @returns {String} - HTMLコンテンツ
       */
      function buildPopup(item) {
        return `
          <strong>${item.pjName}</strong><br>
          Address: ${item.address}<br>
          Category1: ${item.category1}<br>
          Category2: ${item.category2}<br>
          Developer: ${item.developer}<br>
          Architect: ${item.architect}<br>
          Contractor: ${item.contractor}<br>
          Sales Company: ${item.salesCompany}<br>
          Status: ${item.status}<br>
        `;
      }

      // -------------------------------------------------------
      // 5) Show/Hide List
      // -------------------------------------------------------
      /**
       * リスト表示の切り替え関数
       */
      function toggleList() {
        const listArea = document.getElementById('propertyListArea');
        const toggleIcon = document.getElementById('toggleIcon');  // アイコンを取得

        if (listArea.classList.contains('hidden')) {
            listArea.classList.remove('hidden');
            toggleIcon.classList.remove('fa-angles-down');  // "down"アイコンを削除
            toggleIcon.classList.add('fa-angles-up');   // "up"アイコンを追加
        } else {
            listArea.classList.add('hidden');
            toggleIcon.classList.remove('fa-angles-up');  // "up"アイコンを削除
            toggleIcon.classList.add('fa-angles-down');       // "down"アイコンを追加
        }
      }

      // -------------------------------------------------------
      // 6) Simple Search
      // -------------------------------------------------------
      /**
       * 簡易検索関数
       * @param {Array} data - 物件データ
       * @param {String} rawQuery - ユーザーのクエリ
       * @returns {Array} - 検索結果
       */
      function simpleSearch(data, rawQuery) {
        const tokens = rawQuery.toLowerCase().split(/\s+/);
        const notWords = tokens.filter(t => t.startsWith("-")).map(t => t.slice(1));
        const andWords = tokens.filter(t => !t.startsWith("-") && t !== "and" && t !== "or");

        /**
         * アイテムのテキストを構築
         * @param {Object} item - 物件データ
         * @returns {String} - 結合されたテキスト
         */
        function buildText(item) {
          const combined = [
            item.pjName,
            item.address,
            item.category1,
            item.category2,
            item.developer,
            item.architect,
            item.contractor,
            item.salesCompany,
            item.status,
            item.siteArea
          ].join(" ").toLowerCase().replace(/\s+/g, "");
          return combined;
        }

        let idxSet = new Set(data.map((_, i) => i));
        // AND条件
        andWords.forEach(w => {
          idxSet = new Set([...idxSet].filter(idx => {
            const txt = buildText(data[idx]);
            return txt.includes(w);
          }));
        });
        // NOT条件
        notWords.forEach(n => {
          idxSet.forEach(idx => {
            const txt = buildText(data[idx]);
            if (txt.includes(n)) {
              idxSet.delete(idx);
            }
          });
        });
        return [...idxSet].map(i => data[i]);
      }

      // -------------------------------------------------------
      // 7) Complex Search (parentheses, AND/OR/NOT, : = > >=)
      // -------------------------------------------------------
      /**
       * 複雑な検索クエリを解析してフィルタリングする関数
       * @param {String} query - ユーザーのクエリ
       * @param {Array} data - 物件データ
       * @returns {Array} - 検索結果
       */
      function parseComplexQuery(query, data) {
        const tokens = tokenizeComplex(query);
        const ast = parseExpression(tokens);
        if (tokens.length > 0) {
          throw new Error("Extra tokens remain. Check parentheses or operators.");
        }
        return data.filter(item => evaluateAST(ast, item));
      }

      /**
       * クエリをトークンに分解する関数
       * @param {String} q - クエリ文字列
       * @returns {Array} - トークンの配列
       */
      function tokenizeComplex(q) {
        const pattern = /\(|\)|\bAND\b|\bOR\b|\bNOT\b|>=|>|=|:|"[^"]*"|\S+/gi;
        const raw = q.match(pattern) || [];
        const tokens = [];
        raw.forEach(t => {
          const upper = t.toUpperCase();
          if (upper === 'AND' || upper === 'OR' || upper === 'NOT'
           || t === '(' || t === ')' || t === '>' || t === '>='
           || t === '=' || t === ':') {
            tokens.push({ type: upper, text: t });
          } else if (t.startsWith('"') && t.endsWith('"')) {
            tokens.push({ type: 'STRING', text: t.slice(1, -1) });
          } else {
            tokens.push({ type: 'WORD', text: t });
          }
        });
        return tokens;
      }

      /**
       * 式を解析する関数
       * @param {Array} tokens - トークンの配列
       * @returns {Object} - 抽象構文木（AST）
       */
      function parseExpression(tokens) {
        let left = parseTerm(tokens);
        while (peek(tokens, 'OR')) {
          consume(tokens, 'OR');
          const right = parseTerm(tokens);
          left = { type: 'OR', left, right };
        }
        return left;
      }

      function parseTerm(tokens) {
        let left = parseFactor(tokens);
        while (peek(tokens, 'AND')) {
          consume(tokens, 'AND');
          const right = parseFactor(tokens);
          left = { type: 'AND', left, right };
        }
        return left;
      }

      function parseFactor(tokens) {
        let isNot = false;
        if (peek(tokens, 'NOT')) {
          consume(tokens, 'NOT');
          isNot = true;
        }
        let node;
        if (peek(tokens, '(')) {
          consume(tokens, '(');
          node = parseExpression(tokens);
          consume(tokens, ')');
        } else {
          node = parseCondition(tokens);
        }
        if (isNot) {
          node = { type: 'NOT', expr: node };
        }
        return node;
      }

      function parseCondition(tokens) {
        const colToken = consumeType(tokens, ['WORD']);
        const opToken = nextToken(tokens);
        if (![':', '=', '>', '>='].includes(opToken.text)) {
          throw new Error(`Invalid operator: ${opToken.text}`);
        }
        const valToken = consumeType(tokens, ['WORD','STRING']);
        return {
          type: 'COND',
          column: colToken.text,
          op: opToken.text,
          value: valToken.text
        };
      }

      function peek(tokens, text) {
        return tokens[0] && tokens[0].text.toUpperCase() === text.toUpperCase();
      }

      function consume(tokens, text) {
        if (!peek(tokens, text)) {
          throw new Error(`Expected "${text}" but got "${tokens[0]?.text}"`);
        }
        return tokens.shift();
      }

      function consumeType(tokens, types) {
        if (!tokens[0] || !types.includes(tokens[0].type)) {
          throw new Error(`Expected one of [${types.join(', ')}], got ${tokens[0]?.type}`);
        }
        return tokens.shift();
      }

      function nextToken(tokens) {
        if (!tokens.length) throw new Error("Unexpected end of tokens.");
        return tokens.shift();
      }

      /**
       * 抽象構文木（AST）を評価する関数
       * @param {Object} ast - 抽象構文木
       * @param {Object} item - 物件データ
       * @returns {Boolean} - 評価結果
       */
      function evaluateAST(ast, item) {
        switch (ast.type) {
          case 'OR':
            return evaluateAST(ast.left, item) || evaluateAST(ast.right, item);
          case 'AND':
            return evaluateAST(ast.left, item) && evaluateAST(ast.right, item);
          case 'NOT':
            return !evaluateAST(ast.expr, item);
          case 'COND':
            return evaluateCondition(ast, item);
          default:
            throw new Error("Unknown AST node type: " + ast.type);
        }
      }

      /**
       * 条件を評価する関数
       * @param {Object} cond - 条件オブジェクト
       * @param {Object} item - 物件データ
       * @returns {Boolean} - 評価結果
       */
      function evaluateCondition(cond, item) {
        const col = cond.column.toLowerCase();
        const op  = cond.op;
        const val = cond.value;
        let fieldVal = (item[col] || "").toString().toLowerCase();
        let fieldNum = parseFloat(item[col]);

        switch (op) {
          case ':':
            return fieldVal.includes(val.toLowerCase());
          case '=':
            return fieldVal === val.toLowerCase();
          case '>':
          case '>=': {
            if (isNaN(fieldNum)) return false;
            const cmp = parseFloat(val);
            if (isNaN(cmp)) return false;
            return (op === '>') ? (fieldNum > cmp) : (fieldNum >= cmp);
          }
          default:
            return false;
        }
      }

      // -------------------------------------------------------
      // 8) handleGeoSearch (Nominatim)
      // -------------------------------------------------------
      let boundaryLayer = null;
      let maskLayer = null;

      const geoSearchBox = document.getElementById('geoSearchBox');

      geoSearchBox.addEventListener('keydown', async (event) => {
          if (event.key === 'Enter') {
              await handleGeoSearch();
          }
      });

      /**
       * 地域検索処理
       */
      async function handleGeoSearch() {
        const q = geoSearchBox.value.trim();
        if (!q) {
          alert("Please enter a place name.");
          return;
        }

        closeUIElements();

        try {
          // ローディングスピナーを表示
          showLoadingSpinner('geoLoadingSpinner');

          // 既存のレイヤーを削除
          if (boundaryLayer) map.removeLayer(boundaryLayer);
          if (maskLayer) map.removeLayer(maskLayer);

          // Nominatim APIを使用して地理情報を取得
          const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}&polygon_geojson=1`;
          const response = await fetch(url);
          if (!response.ok) throw new Error("Network response was not ok.");
          const data = await response.json();

          if (!data.length) {
            alert("No matching location found.");
            return;
          }

          const result = data[0];

          if (result.geojson) {
            // 境界線を描画
            boundaryLayer = L.geoJSON(result.geojson, {
              style: {
                color: '#FF000DA8',
                weight: 1.7,
                opacity: 1,
                fillOpacity: 0,
                dashArray: '2, 3'
              }
            }).addTo(map);

            // マスクレイヤーを作成
            const worldBounds = [
              [[-90, -180], [90, -180], [90, 180], [-90, 180], [-90, -180]]
            ];

            if (result.geojson.type === 'Polygon') {
              worldBounds.push(result.geojson.coordinates[0].map(p => [p[1], p[0]]).reverse());
            } else if (result.geojson.type === 'MultiPolygon') {
              result.geojson.coordinates.forEach(poly => {
                worldBounds.push(poly[0].map(p => [p[1], p[0]]).reverse());
              });
            }

            maskLayer = L.polygon(worldBounds, {
              color: 'none',
              fillColor: '#000',
              fillOpacity: 0.1
            }).addTo(map);
            maskLayer.bringToBack();

            // 地図を境界に合わせる
            map.fitBounds(boundaryLayer.getBounds(), { padding: [20, 20] });
          } else {
            // 境界がない場合は中心点に移動
            map.setView([result.lat, result.lon], 13);
          }

        } catch(e) {
          console.error(e);
          alert("Search failed. Please try again.");
        } finally {
          // ローディングスピナーを非表示
          hideLoadingSpinner('geoLoadingSpinner');
        }
      }

      /**
       * 地理検索ボックスをクリアする関数
       */
      function clearGeoSearch() {
        geoSearchBox.value = '';

        // 検索結果をクリアする（既存の地理検索結果レイヤーを削除）
        if (boundaryLayer) {
          map.removeLayer(boundaryLayer);
          boundaryLayer = null;
        }
        if (maskLayer) {
          map.removeLayer(maskLayer);
          maskLayer = null;
        }
      }

      /**
       * 物件検索ボックスをクリアする関数
       */
      function clearPropertySearch() {
        propertySearchBox.value = '';

        // 検索結果をクリアする（マーカーとポリゴンを削除）
        propertyMarkers.forEach(marker => map.removeLayer(marker));
        propertyMarkers.length = 0;

        propertyPolygons.forEach(polygon => map.removeLayer(polygon));
        propertyPolygons.length = 0;

        const ul = document.getElementById('propertyResultUl');
        ul.innerHTML = "";
      }

      // -------------------------------------------------------
      // **) Close UI Elements
      // -------------------------------------------------------
      /**
       * UI要素を閉じる関数
       */
      function closeUIElements() {
        const menuContainer = document.getElementById('menuContainer');
        const listArea = document.getElementById('propertyListArea');
        const mapElement = document.getElementById('map');

        // 携帯表示（モバイル用クラス）
        if (window.innerWidth < 769) {
            if (menuContainer) {
                menuContainer.classList.remove('full', 'half');
                menuContainer.classList.add('closed'); // スライドダウン
            }
        } 
        // PC表示（スタイル変更）
        else {
            if (menuContainer) {
                menuContainer.style.transform = 'translateX(-280px)'; // メニューを隠す
            }
        }

        // 物件リストを非表示にする
        if (listArea) {
            listArea.classList.add('hidden');
        }

        // モバイルキーボードを閉じる
        document.activeElement.blur();

        // 地図にフォーカスを移動
        if (mapElement) {
            mapElement.focus();
        }
      }

      // -------------------------------------------------------
      // 9) Real-time Current Location
      // -------------------------------------------------------
      let currentLocMarker = null;
      let watchID = null;
      let trackingActive = false;

      const currentLocationBtn = document.getElementById('currentLocationBtn');

      currentLocationBtn.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          toggleCurrentLocation();
        }
      });

      /**
       * 現在位置の追跡を切り替える関数
       */
      function toggleCurrentLocation() {
        const btnIcon = document.querySelector('#currentLocationBtn img'); // ボタン内のアイコン画像を取得

        if (!trackingActive) {
            // リアルタイム追跡を開始
            if (!navigator.geolocation) {
              alert("Geolocation is not supported by this browser.");
              return;
            }
            watchID = navigator.geolocation.watchPosition(
              positionSuccess,
              positionError,
              { enableHighAccuracy: true }
            );
            btnIcon.src = "https://img.icons8.com/?size=100&id=ziC1TV1ikKi9&format=png&color=004ACD99"; // 追跡中のアイコン
            btnIcon.alt = "Tracking Current Location";
            trackingActive = true;
        } else {
            // リアルタイム追跡を停止
            if (watchID !== null) {
              navigator.geolocation.clearWatch(watchID);
              watchID = null;
            }
            if (currentLocMarker) {
              map.removeLayer(currentLocMarker);
              currentLocMarker = null;
            }
            btnIcon.src = "https://img.icons8.com/?size=100&id=ziC1TV1ikKi9&format=png&color=004ACD63"; // 停止中のアイコン
            btnIcon.alt = "Stop Tracking Location";
            trackingActive = false;
        }
      }

      /**
       * 現在位置取得成功時のコールバック
       * @param {Object} pos - GeolocationPositionオブジェクト
       */
      function positionSuccess(pos) {
        const lat = pos.coords.latitude;
        const lng = pos.coords.longitude;
        console.log("Current position:", lat, lng);

        // マーカーがまだ作成されていない場合、作成
        if (!currentLocMarker) {
            const divIcon = L.divIcon({
              html: '<div class="blinking-marker"></div>',
              className: '',
              iconSize: [18, 18],
              iconAnchor: [9, 9]
            });
            currentLocMarker = L.marker([lat, lng], { icon: divIcon }).addTo(map);
        } else {
            // 位置を更新
            currentLocMarker.setLatLng([lat, lng]);
        }

        // 現在位置にスムーズに移動
        map.flyTo([lat, lng], 16);
      }

      /**
       * 現在位置取得失敗時のコールバック
       * @param {Object} err - GeolocationPositionErrorオブジェクト
       */
      function positionError(err) {
        console.error("Geolocation error:", err);
        alert("Failed to get current location: " + err.message);
      }

      // -------------------------------------------------------
      // 10) Menu Container 改善
      // -------------------------------------------------------
      document.addEventListener('DOMContentLoaded', () => {
        const menuContainer = document.getElementById('menuContainer');
        const menuToggleBtn = document.getElementById('menuToggleBtn');
        const menuDragHandle = document.getElementById('menuDragHandle');

        // PC用の状態管理
        let isMenuOpen = false;
        let isHovering = false;

        // モバイル用の状態管理
        let startY = 0;
        let isDragging = false;

        // デバイスチェック関数
        const isPCView = () => window.innerWidth >= 769;

        /**
         * メニューの位置を更新する関数
         * @param {Number} position - メニューのX位置
         */
        function updateMenuPosition(position) {
          if (isPCView()) {
            menuContainer.style.transform = `translateX(${position}px)`;
          }
        }

        /**
         * メニュートグルボタンのクリックイベントハンドラ
         * @param {Event} e - クリックイベント
         */
        function handleMenuToggle(e) {
          if (isPCView()) {
            e.stopPropagation();
            isMenuOpen = !isMenuOpen;
            updateMenuPosition(isMenuOpen ? 0 : -280);
            menuToggleBtn.innerHTML = isMenuOpen ? '&times;' : '☰';
            menuToggleBtn.setAttribute('aria-pressed', isMenuOpen);
          }
        }

        /**
         * メニュー外クリック時にメニューを閉じる関数
         * @param {Event} e - クリックイベント
         */
        function handleDocumentClick(e) {
          if (isPCView() && isMenuOpen && 
              !menuContainer.contains(e.target) && 
              e.target !== menuToggleBtn) {
            isMenuOpen = false;
            updateMenuPosition(-280);
            menuToggleBtn.innerHTML = '☰';
            menuToggleBtn.setAttribute('aria-pressed', isMenuOpen);
          }
        }

        /**
         * メニューコンテナのホバーイベントハンドラ
         */
        function handleMenuHover() {
          if (isPCView() && !isMenuOpen) {
            isHovering = true;
            updateMenuPosition(-200);
          }
        }

        /**
         * メニューコンテナのホバー終了イベントハンドラ
         */
        function handleMenuHoverEnd() {
          if (isPCView() && !isMenuOpen) {
            isHovering = false;
            updateMenuPosition(-280);
          }
        }

        /**
         * メニューコンテナのクリックイベントハンドラ
         * @param {Event} e - クリックイベント
         */
        function handleMenuClick(e) {
          if (isPCView() && !isMenuOpen && isHovering) {
            isMenuOpen = true;
            updateMenuPosition(0);
            menuToggleBtn.innerHTML = '&times;';
            menuToggleBtn.setAttribute('aria-pressed', isMenuOpen);
            e.stopPropagation();
          }
        }

        /**
         * モバイル用のメニュードラッグイベントハンドラ
         * @param {TouchEvent} e - タッチイベント
         */
        function handleMenuDragStart(e) {
          if (!isPCView()) {
            startY = e.touches[0].clientY;
            isDragging = true;
          }
        }

        /**
         * モバイル用のメニュードラッグ移動イベントハンドラ
         * @param {TouchEvent} e - タッチイベント
         */
        function handleMenuDragMove(e) {
          if (!isDragging || isPCView()) return;
          const currentY = e.touches[0].clientY;
          const deltaY = currentY - startY;

          if (deltaY > 50) {
            setMenuState('closed');
          } else if (deltaY > -50 && deltaY < 50) {
            setMenuState('half');
          } else if (deltaY < -50) {
            setMenuState('full');
          }
        }

        /**
         * モバイル用のメニュードラッグ終了イベントハンドラ
         */
        function handleMenuDragEnd() {
          if (!isPCView()) {
            isDragging = false;
          }
        }

        /**
         * メニューの状態を設定する関数
         * @param {String} state - 'closed', 'half', 'full'
         */
        function setMenuState(state) {
          if (!isPCView()) {
            menuContainer.classList.remove('closed', 'half', 'full');
            menuContainer.classList.add(state);
          }
        }

        // メニュートグルボタンにイベントリスナーを追加
        if (menuToggleBtn) {
          menuToggleBtn.addEventListener('click', handleMenuToggle);
          menuToggleBtn.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              handleMenuToggle(e);
            }
          });
        }

        // ドキュメント全体にクリックイベントリスナーを追加
        document.addEventListener('click', handleDocumentClick);

        // メニューコンテナにホバーイベントリスナーを追加
        if (menuContainer) {
          menuContainer.addEventListener('mouseenter', handleMenuHover);
          menuContainer.addEventListener('mouseleave', handleMenuHoverEnd);
          menuContainer.addEventListener('click', handleMenuClick);
        }

        // メニューコンテナにドラッグイベントリスナーを追加
        if (menuDragHandle) {
          menuDragHandle.addEventListener('touchstart', handleMenuDragStart);
          menuDragHandle.addEventListener('touchmove', handleMenuDragMove);
          menuDragHandle.addEventListener('touchend', handleMenuDragEnd);
        }

        // リサイズイベントに対応
        window.addEventListener('resize', () => {
          if (isPCView()) {
            updateMenuPosition(isMenuOpen ? 0 : -280);
            menuContainer.classList.remove('closed', 'half', 'full');
          } else {
            menuContainer.style.transform = '';
            menuContainer.classList.add('closed');
            isMenuOpen = false;
            isHovering = false;
          }
        });
      });

      // -------------------------------------------------------
      // 11) Utility Functions
      // -------------------------------------------------------
      /**
       * ローディングスピナーを表示する関数
       * @param {String} spinnerId - スピナーのID
       */
      function showLoadingSpinner(spinnerId) {
        const spinner = document.getElementById(spinnerId);
        if (spinner) {
          spinner.classList.add('loading');
          spinner.setAttribute('aria-hidden', 'false');
        }
      }

      /**
       * ローディングスピナーを非表示にする関数
       * @param {String} spinnerId - スピナーのID
       */
      function hideLoadingSpinner(spinnerId) {
        const spinner = document.getElementById(spinnerId);
        if (spinner) {
          spinner.classList.remove('loading');
          spinner.setAttribute('aria-hidden', 'true');
        }
      }

      // -------------------------------------------------------
      // 12) Expose Functions to Global Scope
      // -------------------------------------------------------
      // これらの関数をグローバルスコープに公開する
      window.clearGeoSearch = clearGeoSearch;
      window.clearPropertySearch = clearPropertySearch;
      window.toggleCurrentLocation = toggleCurrentLocation;
      window.toggleList = toggleList;

    })();
  </script>
</body>
</html>
